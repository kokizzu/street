<html><head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>/*! title */</title>
	<meta content="HapSTR" property="og:site_name">
	<meta content="#{title}" property="og:title">
	<meta content="tw_TW" property="og:locale">
	<meta content="en_EN" property="og:locale:alternate">

    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png">
    <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#F97316">
    <link rel="shortcut icon" href="/assets/favicons/favicon.ico">
    <meta name="apple-mobile-web-app-title" content="HapSTR">
    <meta name="application-name" content="HapSTR">
    <meta name="msapplication-TileColor" content="#F97316">
    <meta name="msapplication-config" content="/assets/favicons/browserconfig.xml">
    <meta name="theme-color" content="#FFF">
</head>
<body>
<style>
    *,
    *::before,
    *::after {
        box-sizing : border-box;
    }

    :root {
        -moz-tab-size : 4;
        -o-tab-size   : 4;
        tab-size      : 4;
    }

    html {
        max-width                : 100%;
        margin                   : auto;
        line-height-step         : 1.15;
        -webkit-text-size-adjust : 100%;
        font-size                : 13px;
    }

    body {
        font-family : Roboto, Helvetica, Arial, sans-serif;
        margin      : 0;
    }

    hr {
        height           : 0;
        border-top-width : 1px;
        width            : 100%;
        overflow         : hidden;
        color            : inherit;
        margin           : 0;
    }


    .label_rent {
        background-color : #1080E8 !important;
        color            : #FFF !important;
        border           : none !important;
    }

    .label_sale {
        background-color : #F97316 !important;
        color            : #FFF !important;
        border           : none !important;
    }
</style>


<main id="app"></main><script>document.getElementById('app').innerHTML=''</script><!---->


<style>/* fakecss:./_components/PillBox.esbuild-svelte-fake-css */
.pill-box.svelte-103uryn.svelte-103uryn {
  line-height: 25px;
  display: inline-flex;
}
.pill-box.svelte-103uryn .label.svelte-103uryn,
.pill-box.svelte-103uryn .content.svelte-103uryn {
  border: 1px solid var(--blue-005);
  border-radius: 5px;
  padding: 2px;
  margin-bottom: 1em;
}
.pill-box.svelte-103uryn .label.svelte-103uryn {
  background-color: var(--blue-005);
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
  padding-left: 6px;
  padding-right: 6px;
  text-align: center;
  color: #FFF;
  text-wrap: nowrap;
  padding: auto;
  display: inline-flex;
  align-items: center;
}
.pill-box.svelte-103uryn .content.svelte-103uryn {
  background-color: #FFF;
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
  border-left: 0;
  padding-left: 5px;
  padding-right: 5px;
  margin-right: 1em;
}

/* fakecss:./_components/Property.esbuild-svelte-fake-css */
.property.svelte-rlah51.svelte-rlah51.svelte-rlah51 {
  height: fit-content;
  background-color: #F0F0F0;
  border-radius: 8px;
  padding: 15px 15px 70px 15px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  position: relative;
}
.property.svelte-rlah51 h3.svelte-rlah51.svelte-rlah51 {
  font-size: 22px;
  margin: 0 0 15px 0;
  text-align: center;
}
.property_main.svelte-rlah51.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  align-content: flex-start;
  justify-content: flex-start;
  align-items: flex-start;
  gap: 20px;
}
.property_main.svelte-rlah51 .property_images.svelte-rlah51.svelte-rlah51 {
  width: 340px;
  height: 190px;
  flex: none;
  overflow: hidden;
  border-radius: 8px;
}
.property_main.svelte-rlah51 .property_images img.svelte-rlah51.svelte-rlah51 {
  object-fit: cover;
  width: 100%;
  height: 100%;
}
.property_main.svelte-rlah51 .property_images .image_empty.svelte-rlah51.svelte-rlah51 {
  border-radius: 8px;
  object-fit: cover;
  width: 100%;
  height: 100%;
  background-color: rgb(0 0 0 / 0.06);
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-size: 18px;
  justify-content: center;
  align-items: center;
}
.property_main.svelte-rlah51 .property_info.svelte-rlah51.svelte-rlah51 {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 20px;
}
.property_main.svelte-rlah51 .property_info .col1.svelte-rlah51.svelte-rlah51 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-direction: row;
}
.property_main.svelte-rlah51 .property_info .col1 .left.svelte-rlah51.svelte-rlah51 {
  display: flex;
  gap: 15px;
  align-items: center;
}
.property_main.svelte-rlah51 .property_info .col1 .prop_status.svelte-rlah51.svelte-rlah51 {
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 15px;
}
.property_main.svelte-rlah51 .property_info .col1 .approved.svelte-rlah51.svelte-rlah51 {
  background-color: rgba(140, 216, 107, 1);
  color: #FFF;
}
.property_main.svelte-rlah51 .property_info .col1 .pending.svelte-rlah51.svelte-rlah51 {
  background-color: rgba(255, 208, 118, 1);
  color: #475569;
}
.property_main.svelte-rlah51 .property_info .col1 .rejected.svelte-rlah51.svelte-rlah51 {
  background-color: rgba(255, 126, 118, 1);
  color: #FFF;
}
.property_main.svelte-rlah51 .property_info .col1 .left .purpose.svelte-rlah51.svelte-rlah51,
.property_main.svelte-rlah51 .property_info .col1 .left .house_type.svelte-rlah51.svelte-rlah51,
.property_main.svelte-rlah51 .property_info .col1 .edit_property.svelte-rlah51.svelte-rlah51 {
  background-color: #F97316;
  padding: 7px 18px;
  border-radius: 8px;
  color: white;
  font-size: 14px;
  text-transform: capitalize;
  text-decoration: none;
}
.property_main.svelte-rlah51 .property_info .col1 .left .house_type.svelte-rlah51.svelte-rlah51,
.property_main.svelte-rlah51 .property_info .col1 .edit_property.svelte-rlah51.svelte-rlah51 {
  display: flex;
  gap: 10px;
  align-items: center;
}
.property_main.svelte-rlah51 .property_info .col1 .edit_property.svelte-rlah51.svelte-rlah51:hover {
  background-color: #F58433;
}
.property_main.svelte-rlah51 .property_info .col2.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.property_main.svelte-rlah51 .property_info .col2 h1.svelte-rlah51.svelte-rlah51 {
  margin: 0;
  font-size: 32px;
}
.property_main.svelte-rlah51 .property_info .col2 p.svelte-rlah51.svelte-rlah51 {
  margin: 0 0 10px 0;
}
.property_main.svelte-rlah51 .property_info .col2 .address.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
}
.icon_address {
  flex-shrink: 0;
}
.property_main.svelte-rlah51 .property_info .col2 .address span.svelte-rlah51.svelte-rlah51 {
  flex-shrink: 1;
}
.property_secondary.svelte-rlah51.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.property_secondary.svelte-rlah51 .feature_number.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-evenly;
  width: 100%;
}
.property_secondary.svelte-rlah51 .feature_number .feature_item.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  text-transform: capitalize;
}
.property_secondary.svelte-rlah51 p.svelte-rlah51.svelte-rlah51 {
  margin: 0;
}
.property_secondary.svelte-rlah51 b.svelte-rlah51.svelte-rlah51 {
  font-size: 22px;
}
.property_floors.svelte-rlah51.svelte-rlah51.svelte-rlah51 {
  width: 70%;
  margin: 0 auto;
}
.property_floors.svelte-rlah51 h3.svelte-rlah51.svelte-rlah51 {
  font-size: 22px;
  margin: 0 0 15px 0;
  text-align: center;
}
.property_floors.svelte-rlah51 .floor_lists.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item.svelte-rlah51.svelte-rlah51 {
  display: flex;
  align-items: flex-start;
  gap: 35px;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item .left.svelte-rlah51.svelte-rlah51 {
  flex-grow: 1;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item .left h5.svelte-rlah51.svelte-rlah51 {
  font-size: 22px;
  text-transform: capitalize;
  font-weight: normal;
  margin: 0 0 15px 0;
  width: 100%;
}
.property_floors.svelte-rlah51 .floor_lists .floor_lists .floor_item .left.svelte-rlah51 .room_lists.svelte-rlah51 {
  font-size: 14px;
  width: 100%;
  color: #475569;
  border: 1px solid #CBD5E1;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item .left.svelte-rlah51 .room_lists .room_item.svelte-rlah51 {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  text-transform: capitalize;
  border-bottom: 1px solid #CBD5E1;
  padding: 5px 0;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item .floor_plan_image.svelte-rlah51.svelte-rlah51 {
  width: 240px;
  height: 140px;
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #CBD5E1;
  margin-top: 45px;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item .floor_plan_image img.svelte-rlah51.svelte-rlah51 {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.property_floors.svelte-rlah51 .floor_lists .floor_item .floor_plan_image .image_empty.svelte-rlah51.svelte-rlah51 {
  border-radius: 8px;
  object-fit: cover;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 8px;
  justify-content: center;
  align-items: center;
}
.property_history.svelte-rlah51 .history_list.svelte-rlah51.svelte-rlah51 {
  padding: 15px;
  background-color: rgb(0 0 0 / 0.06);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  min-height: 200px;
}
.property_history.svelte-rlah51 .history_list .item.svelte-rlah51.svelte-rlah51 {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  padding: 10px 0;
  border-bottom: 1px solid #CBD5E1;
  font-size: 15px;
  font-weight: 600;
}

/* fakecss:./user/property/index.esbuild-svelte-fake-css */
.property_container.svelte-2tq1rc.svelte-2tq1rc {
  width: 100%;
  margin: 30px auto 50px auto;
  color: #475569;
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 30px;
}
.property.svelte-2tq1rc.svelte-2tq1rc {
  width: 60%;
}
.side_attribute.svelte-2tq1rc.svelte-2tq1rc {
  width: 250px;
  height: fit-content;
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.side_attribute.svelte-2tq1rc .login_container.svelte-2tq1rc,
.side_attribute.svelte-2tq1rc .share_container.svelte-2tq1rc {
  text-align: center;
  height: fit-content;
  background-color: #F0F0F0;
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.side_attribute.svelte-2tq1rc .login_container h3.svelte-2tq1rc {
  margin: 0 0 10px 0;
  font-size: 24px;
}
.side_attribute.svelte-2tq1rc .login_container .login_btn.svelte-2tq1rc {
  background-color: #6366F1;
  width: 100%;
  height: fit-content;
  padding: 12px;
  text-align: center;
  border-radius: 8px;
  color: #FFF;
  font-size: 13px;
  display: flex;
  flex-direction: row;
  gap: 6px;
  justify-content: center;
  align-items: center;
  text-decoration: none;
}
.side_attribute.svelte-2tq1rc .login_container .login_btn.svelte-2tq1rc:hover {
  background-color: #7E80F1;
}
.side_attribute.svelte-2tq1rc .share_container header.svelte-2tq1rc {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 7px;
  align-items: center;
  font-size: 15px;
}
.side_attribute.svelte-2tq1rc .share_container .share_options.svelte-2tq1rc {
  display: grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  grid-template-rows: repeat(2, minmax(0, 1fr));
  align-items: center;
  justify-items: center;
  justify-content: center;
  align-content: center;
  row-gap: 12px;
}
.side_attribute.svelte-2tq1rc .share_container .share_options .share_item.svelte-2tq1rc {
  border: none;
  background: none;
  cursor: pointer;
}
.side_attribute .share_container .share_options .share_item:hover .share_icon {
  fill: #57667A !important;
}
</style>
<script>(() => {
  // node_modules/svelte/src/runtime/internal/utils.js
  function noop() {
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url) {
    if (element_src === url)
      return true;
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function null_to_empty(value) {
    return value == null ? "" : value;
  }

  // node_modules/svelte/src/runtime/internal/globals.js
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton = class {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element3, listener) {
      this._listeners.set(element3, listener);
      this._getObserver().observe(element3, this.options);
      return () => {
        this._listeners.delete(element3);
        this._observer.unobserve(element3);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          ResizeObserverSingleton.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

  // node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function comment(content) {
    return document.createComment(content);
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function children(element3) {
    return Array.from(element3.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.data === data)
      return;
    text2.data = /** @type {string} */
    data;
  }
  function get_custom_elements_slots(element3) {
    const result = {};
    element3.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$.on_mount.push(fn);
  }

  // node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = /* @__PURE__ */ Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$);
        }
      } catch (e) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($) {
    if ($.fragment !== null) {
      $.update();
      run_all($.before_update);
      const dirty = $.dirty;
      $.dirty = [-1];
      $.fragment && $.fragment.p($.ctx, dirty);
      $.after_update.forEach(add_render_callback);
    }
  }
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
  }

  // node_modules/svelte/src/runtime/internal/transitions.js
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
      // parent group
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach3, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach3)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  // node_modules/svelte/src/runtime/internal/each.js
  function ensure_array_like(array_like_or_iterator) {
    return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }

  // node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

  // node_modules/svelte/src/runtime/internal/Component.js
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor) {
    const { fragment, after_update } = component.$;
    fragment && fragment.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$.on_mount.map(run).filter(is_function);
      if (component.$.on_destroy) {
        component.$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $ = component.$;
    if ($.fragment !== null) {
      flush_render_callbacks($.after_update);
      run_all($.on_destroy);
      $.fragment && $.fragment.d(detaching);
      $.on_destroy = $.fragment = null;
      $.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$.dirty.fill(0);
    }
    component.$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance5, create_fragment5, not_equal, props, append_styles = null, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $ = component.$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$.root
    };
    append_styles && append_styles($.root);
    let ready = false;
    $.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($.ctx && not_equal($.ctx[i], $.ctx[i] = value)) {
        if (!$.skip_bound && $.bound[i])
          $.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $.update();
    ready = true;
    run_all($.before_update);
    $.fragment = create_fragment5 ? create_fragment5($.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $.fragment && $.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $.fragment && $.fragment.c();
      }
      if (options.intro)
        transition_in(component.$.fragment);
      mount_component(component, options.target, options.anchor);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $ctor;
      /** Slots */
      $s;
      /** The Svelte component instance */
      $c;
      /** Whether or not the custom element is connected */
      $cn = false;
      /** Component props data */
      $d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $l_u = /* @__PURE__ */ new Map();
      constructor($componentCtor, $slots, use_shadow_dom) {
        super();
        this.$ctor = $componentCtor;
        this.$s = $slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$l[type] = this.$l[type] || [];
        this.$l[type].push(listener);
        if (this.$c) {
          const unsub = this.$c.$on(type, listener);
          this.$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$c) {
          const unsub = this.$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$l_u.delete(listener);
          }
        }
        if (this.$l[type]) {
          const idx = this.$l[type].indexOf(listener);
          if (idx >= 0) {
            this.$l[type].splice(idx, 1);
          }
        }
      }
      async connectedCallback() {
        this.$cn = true;
        if (!this.$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$cn || this.$c) {
            return;
          }
          const $slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$s) {
            if (name in existing_slots) {
              $slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$g_p(attribute.name);
            if (!(name in this.$d)) {
              this.$d[name] = get_custom_element_value(name, attribute.value, this.$p_d, "toProp");
            }
          }
          for (const key in this.$p_d) {
            if (!(key in this.$d) && this[key] !== void 0) {
              this.$d[key] = this[key];
              delete this[key];
            }
          }
          this.$c = new this.$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$d,
              $slots,
              $scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$r = true;
            for (const key in this.$p_d) {
              this.$d[key] = this.$c.$.ctx[this.$c.$.props[key]];
              if (this.$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$d[key],
                  this.$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$r = false;
          };
          this.$c.$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$l) {
            for (const listener of this.$l[type]) {
              const unsub = this.$c.$on(type, listener);
              this.$l_u.set(listener, unsub);
            }
          }
          this.$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr3, _oldValue, newValue) {
        if (this.$r)
          return;
        attr3 = this.$g_p(attr3);
        this.$d[attr3] = get_custom_element_value(attr3, newValue, this.$p_d, "toProp");
        this.$c?.$set({ [attr3]: this.$d[attr3] });
      }
      disconnectedCallback() {
        this.$cn = false;
        Promise.resolve().then(() => {
          if (!this.$cn && this.$c) {
            this.$c.$destroy();
            this.$c = void 0;
          }
        });
      }
      $g_p(attribute_name) {
        return Object.keys(this.$p_d).find(
          (key) => this.$p_d[key].attribute === attribute_name || !this.$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop, value, props_definition, transform) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform || !props_definition[prop]) {
      return value;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$.callbacks[type] || (this.$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$set && !is_empty(props)) {
        this.$.skip_bound = true;
        this.$set(props);
        this.$.skip_bound = false;
      }
    }
  };

  // node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION = "4";

  // node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/utils.js
  function noop2() {
  }
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return (
      /** @type {T & S} */
      tar
    );
  }
  function run2(fn) {
    return fn();
  }
  function blank_object2() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all2(fns) {
    fns.forEach(run2);
  }
  function is_function2(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal2(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  function is_empty2(obj) {
    return Object.keys(obj).length === 0;
  }

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/globals.js
  var globals2 = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton2 = class {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals2 ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element3, listener) {
      this._listeners.set(element3, listener);
      this._getObserver().observe(element3, this.options);
      return () => {
        this._listeners.delete(element3);
        this._observer.unobserve(element3);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          ResizeObserverSingleton2.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton2.entries = "WeakMap" in globals2 ? /* @__PURE__ */ new WeakMap() : void 0;

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating2 = false;
  function start_hydrating2() {
    is_hydrating2 = true;
  }
  function end_hydrating2() {
    is_hydrating2 = false;
  }
  function insert2(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach2(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function element2(name) {
    return document.createElement(name);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function attr2(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
      attr2(node, key, attributes[key]);
    }
  }
  function children2(element3) {
    return Array.from(element3.childNodes);
  }
  function get_custom_elements_slots2(element3) {
    const result = {};
    element3.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component2;
  function set_current_component2(component) {
    current_component2 = component;
  }

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components2 = [];
  var binding_callbacks2 = [];
  var render_callbacks2 = [];
  var flush_callbacks2 = [];
  var resolved_promise2 = /* @__PURE__ */ Promise.resolve();
  var update_scheduled2 = false;
  function schedule_update2() {
    if (!update_scheduled2) {
      update_scheduled2 = true;
      resolved_promise2.then(flush2);
    }
  }
  function add_render_callback2(fn) {
    render_callbacks2.push(fn);
  }
  var seen_callbacks2 = /* @__PURE__ */ new Set();
  var flushidx2 = 0;
  function flush2() {
    if (flushidx2 !== 0) {
      return;
    }
    const saved_component = current_component2;
    do {
      try {
        while (flushidx2 < dirty_components2.length) {
          const component = dirty_components2[flushidx2];
          flushidx2++;
          set_current_component2(component);
          update2(component.$);
        }
      } catch (e) {
        dirty_components2.length = 0;
        flushidx2 = 0;
        throw e;
      }
      set_current_component2(null);
      dirty_components2.length = 0;
      flushidx2 = 0;
      while (binding_callbacks2.length)
        binding_callbacks2.pop()();
      for (let i = 0; i < render_callbacks2.length; i += 1) {
        const callback = render_callbacks2[i];
        if (!seen_callbacks2.has(callback)) {
          seen_callbacks2.add(callback);
          callback();
        }
      }
      render_callbacks2.length = 0;
    } while (dirty_components2.length);
    while (flush_callbacks2.length) {
      flush_callbacks2.pop()();
    }
    update_scheduled2 = false;
    seen_callbacks2.clear();
    set_current_component2(saved_component);
  }
  function update2($) {
    if ($.fragment !== null) {
      $.update();
      run_all2($.before_update);
      const dirty = $.dirty;
      $.dirty = [-1];
      $.fragment && $.fragment.p($.ctx, dirty);
      $.after_update.forEach(add_render_callback2);
    }
  }
  function flush_render_callbacks2(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks2.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks2 = filtered;
  }

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/transitions.js
  var outroing2 = /* @__PURE__ */ new Set();
  function transition_in2(block, local) {
    if (block && block.i) {
      outroing2.delete(block);
      block.i(local);
    }
  }

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/spread.js
  function get_spread_update(levels, updates) {
    const update3 = {};
    const to_null_out = {};
    const accounted_for = { $scope: 1 };
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update3[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update3))
        update3[key] = void 0;
    }
    return update3;
  }

  // node_modules/svelte-icons-pack/node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes2 = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes2 = /* @__PURE__ */ new Set([..._boolean_attributes2]);

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/Component.js
  function mount_component2(component, target, anchor) {
    const { fragment, after_update } = component.$;
    fragment && fragment.m(target, anchor);
    add_render_callback2(() => {
      const new_on_destroy = component.$.on_mount.map(run2).filter(is_function2);
      if (component.$.on_destroy) {
        component.$.on_destroy.push(...new_on_destroy);
      } else {
        run_all2(new_on_destroy);
      }
      component.$.on_mount = [];
    });
    after_update.forEach(add_render_callback2);
  }
  function destroy_component2(component, detaching) {
    const $ = component.$;
    if ($.fragment !== null) {
      flush_render_callbacks2($.after_update);
      run_all2($.on_destroy);
      $.fragment && $.fragment.d(detaching);
      $.on_destroy = $.fragment = null;
      $.ctx = [];
    }
  }
  function make_dirty2(component, i) {
    if (component.$.dirty[0] === -1) {
      dirty_components2.push(component);
      schedule_update2();
      component.$.dirty.fill(0);
    }
    component.$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init2(component, options, instance5, create_fragment5, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component2;
    set_current_component2(component);
    const $ = component.$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop2,
      not_equal,
      bound: blank_object2(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$.context : [])),
      // everything else
      callbacks: blank_object2(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$.root
    };
    append_styles && append_styles($.root);
    let ready = false;
    $.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($.ctx && not_equal($.ctx[i], $.ctx[i] = value)) {
        if (!$.skip_bound && $.bound[i])
          $.bound[i](value);
        if (ready)
          make_dirty2(component, i);
      }
      return ret;
    }) : [];
    $.update();
    ready = true;
    run_all2($.before_update);
    $.fragment = create_fragment5 ? create_fragment5($.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating2();
        const nodes = children2(options.target);
        $.fragment && $.fragment.l(nodes);
        nodes.forEach(detach2);
      } else {
        $.fragment && $.fragment.c();
      }
      if (options.intro)
        transition_in2(component.$.fragment);
      mount_component2(component, options.target, options.anchor);
      end_hydrating2();
      flush2();
    }
    set_current_component2(parent_component);
  }
  var SvelteElement2;
  if (typeof HTMLElement === "function") {
    SvelteElement2 = class extends HTMLElement {
      /** The Svelte component constructor */
      $ctor;
      /** Slots */
      $s;
      /** The Svelte component instance */
      $c;
      /** Whether or not the custom element is connected */
      $cn = false;
      /** Component props data */
      $d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $l_u = /* @__PURE__ */ new Map();
      constructor($componentCtor, $slots, use_shadow_dom) {
        super();
        this.$ctor = $componentCtor;
        this.$s = $slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$l[type] = this.$l[type] || [];
        this.$l[type].push(listener);
        if (this.$c) {
          const unsub = this.$c.$on(type, listener);
          this.$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$c) {
          const unsub = this.$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$cn = true;
        if (!this.$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element2("slot");
                  if (name !== "default") {
                    attr2(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert2(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach2(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$cn) {
            return;
          }
          const $slots = {};
          const existing_slots = get_custom_elements_slots2(this);
          for (const name of this.$s) {
            if (name in existing_slots) {
              $slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$g_p(attribute.name);
            if (!(name in this.$d)) {
              this.$d[name] = get_custom_element_value2(name, attribute.value, this.$p_d, "toProp");
            }
          }
          this.$c = new this.$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$d,
              $slots,
              $scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$r = true;
            for (const key in this.$p_d) {
              this.$d[key] = this.$c.$.ctx[this.$c.$.props[key]];
              if (this.$p_d[key].reflect) {
                const attribute_value = get_custom_element_value2(
                  key,
                  this.$d[key],
                  this.$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(key);
                } else {
                  this.setAttribute(this.$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$r = false;
          };
          this.$c.$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$l) {
            for (const listener of this.$l[type]) {
              const unsub = this.$c.$on(type, listener);
              this.$l_u.set(listener, unsub);
            }
          }
          this.$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr3, _oldValue, newValue) {
        if (this.$r)
          return;
        attr3 = this.$g_p(attr3);
        this.$d[attr3] = get_custom_element_value2(attr3, newValue, this.$p_d, "toProp");
        this.$c?.$set({ [attr3]: this.$d[attr3] });
      }
      disconnectedCallback() {
        this.$cn = false;
        Promise.resolve().then(() => {
          if (!this.$cn) {
            this.$c.$destroy();
            this.$c = void 0;
          }
        });
      }
      $g_p(attribute_name) {
        return Object.keys(this.$p_d).find(
          (key) => this.$p_d[key].attribute === attribute_name || !this.$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value2(prop, value, props_definition, transform) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform || !props_definition[prop]) {
      return value;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent2 = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component2(this, 1);
      this.$destroy = noop2;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function2(callback)) {
        return noop2;
      }
      const callbacks = this.$.callbacks[type] || (this.$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$set && !is_empty2(props)) {
        this.$.skip_bound = true;
        this.$set(props);
        this.$.skip_bound = false;
      }
    }
  };

  // node_modules/svelte-icons-pack/node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION2 = "4";

  // node_modules/svelte-icons-pack/node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION2);

  // node_modules/svelte-icons-pack/dist/Icon.svelte
  function create_fragment(ctx) {
    let svg;
    let svg_style_value;
    let svg_levels = [
      { width: (
        /*size*/
        ctx[1]
      ) },
      { height: (
        /*size*/
        ctx[1]
      ) },
      { viewBox: (
        /*viewBox*/
        ctx[2]
      ) },
      {
        style: svg_style_value = /*color*/
        ctx[3] ? "color: " + /*color*/
        ctx[3] + ";" : ""
      },
      { "stroke-width": "0" },
      { class: (
        /*className*/
        ctx[4]
      ) },
      /*src*/
      ctx[0].a,
      /*attr*/
      ctx[6],
      { xmlns: "http://www.w3.org/2000/svg" }
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert2(target, svg, anchor);
        svg.innerHTML = /*innerHtml*/
        ctx[5];
      },
      p(ctx2, [dirty]) {
        if (dirty & /*innerHtml*/
        32)
          svg.innerHTML = /*innerHtml*/
          ctx2[5];
        ;
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          dirty & /*size*/
          2 && { width: (
            /*size*/
            ctx2[1]
          ) },
          dirty & /*size*/
          2 && { height: (
            /*size*/
            ctx2[1]
          ) },
          dirty & /*viewBox*/
          4 && { viewBox: (
            /*viewBox*/
            ctx2[2]
          ) },
          dirty & /*color*/
          8 && svg_style_value !== (svg_style_value = /*color*/
          ctx2[3] ? "color: " + /*color*/
          ctx2[3] + ";" : "") && { style: svg_style_value },
          { "stroke-width": "0" },
          dirty & /*className*/
          16 && { class: (
            /*className*/
            ctx2[4]
          ) },
          dirty & /*src*/
          1 && /*src*/
          ctx2[0].a,
          dirty & /*attr*/
          64 && /*attr*/
          ctx2[6],
          { xmlns: "http://www.w3.org/2000/svg" }
        ]));
      },
      i: noop2,
      o: noop2,
      d(detaching) {
        if (detaching) {
          detach2(svg);
        }
      }
    };
  }
  function instance($self, $props, $invalidate) {
    let { src } = $props;
    let { size = "1em" } = $props;
    let { viewBox = void 0 } = $props;
    let { color = "currentColor" } = $props;
    let { title = void 0 } = $props;
    let { className = "" } = $props;
    let innerHtml;
    let attr3 = {};
    $self.$set = ($props2) => {
      if ("src" in $props2)
        $invalidate(0, src = $props2.src);
      if ("size" in $props2)
        $invalidate(1, size = $props2.size);
      if ("viewBox" in $props2)
        $invalidate(2, viewBox = $props2.viewBox);
      if ("color" in $props2)
        $invalidate(3, color = $props2.color);
      if ("title" in $props2)
        $invalidate(7, title = $props2.title);
      if ("className" in $props2)
        $invalidate(4, className = $props2.className);
    };
    $self.$.update = () => {
      if ($self.$.dirty & /*color, src*/
      9) {
        $: {
          $invalidate(6, attr3 = {});
          if (color) {
            if (src.a.stroke !== "none") {
              $invalidate(6, attr3.stroke = "currentColor", attr3);
            }
            if (src.a.fill !== "none") {
              $invalidate(6, attr3.fill = "currentColor", attr3);
            }
          }
        }
      }
      if ($self.$.dirty & /*title, src*/
      129) {
        $: {
          $invalidate(5, innerHtml = (title ? `<title>${title}</title>` : "") + src.c);
        }
      }
    };
    return [src, size, viewBox, color, className, innerHtml, attr3, title];
  }
  var Icon = class extends SvelteComponent2 {
    constructor(options) {
      super();
      init2(this, options, instance, create_fragment, safe_not_equal2, {
        src: 0,
        size: 1,
        viewBox: 2,
        color: 3,
        title: 7,
        className: 4
      });
    }
  };
  var Icon_default = Icon;

  // node_modules/svelte-icons-pack/dist/fa/index.js
  var FaBrandsTelegram = { a: { viewBox: "0 0 496 512" }, c: '<path d="M248,8C111.033,8,0,119.033,0,256S111.033,504,248,504,496,392.967,496,256,384.967,8,248,8ZM362.952,176.66c-3.732,39.215-19.881,134.378-28.1,178.3-3.476,18.584-10.322,24.816-16.948,25.425-14.4,1.326-25.338-9.517-39.287-18.661-21.827-14.308-34.158-23.215-55.346-37.177-24.485-16.135-8.612-25,5.342-39.5,3.652-3.793,67.107-61.51,68.335-66.746.153-.655.3-3.1-1.154-4.384s-3.59-.849-5.135-.5q-3.283.746-104.608,69.142-14.845,10.194-26.894,9.934c-8.855-.191-25.888-5.006-38.551-9.123-15.531-5.048-27.875-7.717-26.8-16.291q.84-6.7,18.45-13.7,108.446-47.248,144.628-62.3c68.872-28.647,83.183-33.623,92.511-33.789,2.052-.034,6.639.474,9.61,2.885a10.452,10.452,0,0,1,3.53,6.716A43.765,43.765,0,0,1,362.952,176.66Z"></path>' };
  var FaBrandsFacebook = { a: { viewBox: "0 0 512 512" }, c: '<path d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5V334.2H141.4V256h52.8V222.3c0-87.1 39.4-127.5 125-127.5c16.2 0 44.2 3.2 55.7 6.4V172c-6-.6-16.5-1-29.6-1c-42 0-58.2 15.9-58.2 57.2V256h83.6l-14.4 78.2H287V510.1C413.8 494.8 512 386.9 512 256h0z"></path>' };
  var FaBrandsWhatsapp = { a: { viewBox: "0 0 448 512" }, c: '<path d="M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"></path>' };
  var FaBrandsLinkedin = { a: { viewBox: "0 0 448 512" }, c: '<path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path>' };
  var FaBrandsTwitter = { a: { viewBox: "0 0 512 512" }, c: '<path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>' };
  var FaSolidMapLocationDot = { a: { viewBox: "0 0 576 512" }, c: '<path d="M408 120c0 54.6-73.1 151.9-105.2 192c-7.7 9.6-22 9.6-29.6 0C241.1 271.9 168 174.6 168 120C168 53.7 221.7 0 288 0s120 53.7 120 120zm8 80.4c3.5-6.9 6.7-13.8 9.6-20.6c.5-1.2 1-2.5 1.5-3.7l116-46.4C558.9 123.4 576 135 576 152V422.8c0 9.8-6 18.6-15.1 22.3L416 503V200.4zM137.6 138.3c2.4 14.1 7.2 28.3 12.8 41.5c2.9 6.8 6.1 13.7 9.6 20.6V451.8L32.9 502.7C17.1 509 0 497.4 0 480.4V209.6c0-9.8 6-18.6 15.1-22.3l122.6-49zM327.8 332c13.9-17.4 35.7-45.7 56.2-77V504.3L192 449.4V255c20.5 31.3 42.3 59.6 56.2 77c20.5 25.6 59.1 25.6 79.6 0zM288 152a40 40 0 1 0 0-80 40 40 0 1 0 0 80z"></path>' };
  var FaSolidHouse = { a: { viewBox: "0 0 576 512" }, c: '<path d="M575.8 255.5c0 18-15 32.1-32 32.1h-32l.7 160.2c0 2.7-.2 5.4-.5 8.1V472c0 22.1-17.9 40-40 40H456c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1H416 392c-22.1 0-40-17.9-40-40V448 384c0-17.7-14.3-32-32-32H256c-17.7 0-32 14.3-32 32v64 24c0 22.1-17.9 40-40 40H160 128.1c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2H104c-22.1 0-40-17.9-40-40V360c0-.9 0-1.9 .1-2.8V287.6H32c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"></path>' };
  var FaSolidShareNodes = { a: { viewBox: "0 0 448 512" }, c: '<path d="M352 224c53 0 96-43 96-96s-43-96-96-96s-96 43-96 96c0 4 .2 8 .7 11.9l-94.1 47C145.4 170.2 121.9 160 96 160c-53 0-96 43-96 96s43 96 96 96c25.9 0 49.4-10.2 66.6-26.9l94.1 47c-.5 3.9-.7 7.8-.7 11.9c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-25.9 0-49.4 10.2-66.6 26.9l-94.1-47c.5-3.9 .7-7.8 .7-11.9s-.2-8-.7-11.9l94.1-47C302.6 213.8 326.1 224 352 224z"></path>' };
  var FaSolidArrowRight = { a: { viewBox: "0 0 448 512" }, c: '<path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"></path>' };
  var FaSolidImage = { a: { viewBox: "0 0 512 512" }, c: '<path d="M0 96C0 60.7 28.7 32 64 32H448c35.3 0 64 28.7 64 64V416c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V96zM323.8 202.5c-4.5-6.6-11.9-10.5-19.8-10.5s-15.4 3.9-19.8 10.5l-87 127.6L170.7 297c-4.6-5.7-11.5-9-18.7-9s-14.2 3.3-18.7 9l-64 80c-5.8 7.2-6.9 17.1-2.9 25.4s12.4 13.6 21.6 13.6h96 32H424c8.9 0 17.1-4.9 21.2-12.8s3.6-17.4-1.4-24.7l-120-176zM112 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"></path>' };
  var FaCopy = { a: { viewBox: "0 0 448 512" }, c: '<path d="M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z"></path>' };

  // _components/formatter.js
  function datetime(unixSec, humanize) {
    if (!unixSec)
      return "";
    let dt = (
      /** @type {Date} */
      new Date(unixSec * 1e3)
    );
    if (typeof unixSec === "string") {
      dt = new Date(unixSec);
    }
    if (!humanize) {
      const newDt = (
        /** @type {string} */
        dt.toISOString()
      );
      return newDt.substring(0, 10) + " " + newDt.substring(11, 16);
    }
    return dt.toLocaleDateString("default", {
      day: "2-digit",
      month: "long",
      year: "numeric"
    });
  }
  function priceNtd(val) {
    return new Number(val).toLocaleString("zh-TW");
  }
  function localeDatetime(unixSec) {
    if (!unixSec)
      return "";
    const dt = (
      /** @type {Date} */
      new Date(Number(unixSec) * 1e3)
    );
    const day = (
      /** @type {string} */
      dt.toLocaleDateString("default", {
        weekday: "long"
      })
    );
    const date = (
      /** @type {number} */
      dt.getDate()
    );
    const month = (
      /** @type {string} */
      dt.toLocaleDateString("default", {
        month: "long"
      })
    );
    const year = (
      /** @type {number} */
      dt.getFullYear()
    );
    let hh = (
      /** @type {string} */
      String(dt.getHours())
    );
    if (Number(hh) < 10)
      hh = "0" + hh;
    let mm = (
      /** @type {string} */
      String(dt.getMinutes())
    );
    if (Number(mm) < 10)
      mm = "0" + mm;
    return `${day}, ${date} ${month} ${year} ${hh}:${mm}`;
  }
  function datetime2(unixSec) {
    if (!unixSec)
      return "-";
    const dt = (
      /** @type {Date} */
      new Date(Number(unixSec) * 1e3)
    );
    const year = (
      /** @type {number} */
      dt.getFullYear()
    );
    const month = (
      /** @type {string} */
      dt.toLocaleDateString("default", {
        month: "long"
      })
    );
    const day = (
      /** @type {string} */
      dt.toLocaleDateString("default", {
        weekday: "long"
      })
    );
    const date = (
      /** @type {string} */
      String(dt.getDate()).padStart(2, "0")
    );
    const hours = (
      /** @type {string} */
      String(dt.getHours()).padStart(2, "0")
    );
    const minutes = (
      /** @type {string} */
      String(dt.getMinutes()).padStart(2, "0")
    );
    const seconds = (
      /** @type {string} */
      String(dt.getSeconds()).padStart(2, "0")
    );
    return `${day}, ${date} ${month} ${year} - ${hours}:${minutes}:${seconds}`;
  }
  function formatPrice(price, currency) {
    try {
      return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency,
        maximumSignificantDigits: 4
      }).format(price);
    } catch (err) {
      console.log("formatPrice failed", err, price, currency);
      return `${currency} ${price}`;
    }
  }
  function getApprovalState(s) {
    if (s == "") {
      return "approved";
    } else if (s.startsWith("pending")) {
      return "pending";
    } else {
      return "rejected";
    }
  }
  function M2ToPing(sizeM2) {
    const value = sizeM2 / 3.30579;
    const minifiedValue = value.toFixed(2);
    return parseFloat(minifiedValue);
  }
  function dateISOFormat(dayTo = 0) {
    const dt = new Date();
    dt.setDate(dt.getDate() + dayTo);
    const date = String(dt.getDate()).padStart(2, "0");
    const month = String(dt.getMonth() + 1).padStart(2, "0");
    const year = dt.getFullYear();
    return `${year}-${month}-${date}`;
  }
  function getYearMonth() {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    return `${year}-${month}`;
  }
  module.exports = {
    datetime,
    priceNtd,
    localeDatetime,
    datetime2,
    formatPrice,
    getApprovalState,
    M2ToPing,
    dateISOFormat,
    getYearMonth
  };

  // _components/PillBox.svelte
  function create_if_block(ctx) {
    let span2;
    let span0;
    let t0;
    let t1;
    let span1;
    let t2;
    return {
      c() {
        span2 = element("span");
        span0 = element("span");
        t0 = text(
          /*label*/
          ctx[0]
        );
        t1 = space();
        span1 = element("span");
        t2 = text(
          /*content*/
          ctx[1]
        );
        attr(span0, "class", "label svelte-103uryn");
        attr(span1, "class", "content svelte-103uryn");
        attr(span2, "class", "pill-box svelte-103uryn");
      },
      m(target, anchor) {
        insert(target, span2, anchor);
        append(span2, span0);
        append(span0, t0);
        append(span2, t1);
        append(span2, span1);
        append(span1, t2);
      },
      p(ctx2, dirty) {
        if (dirty & /*label*/
        1)
          set_data(
            t0,
            /*label*/
            ctx2[0]
          );
        if (dirty & /*content*/
        2)
          set_data(
            t2,
            /*content*/
            ctx2[1]
          );
      },
      d(detaching) {
        if (detaching) {
          detach(span2);
        }
      }
    };
  }
  function create_fragment2(ctx) {
    let if_block_anchor;
    let if_block = (
      /*content*/
      ctx[1] && create_if_block(ctx)
    );
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (
          /*content*/
          ctx2[1]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block)
          if_block.d(detaching);
      }
    };
  }
  function instance2($self, $props, $invalidate) {
    let { label = "label" } = $props;
    let { content = "" } = $props;
    $self.$set = ($props2) => {
      if ("label" in $props2)
        $invalidate(0, label = $props2.label);
      if ("content" in $props2)
        $invalidate(1, content = $props2.content);
    };
    return [label, content];
  }
  var PillBox = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, { label: 0, content: 1 });
    }
  };
  var PillBox_default = PillBox;

  // _components/Property.svelte
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[10] = list[i];
    return child_ctx;
  }
  function get_each_context_1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[13] = list[i];
    return child_ctx;
  }
  function get_each_context_2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[16] = list[i];
    return child_ctx;
  }
  function get_if_ctx(ctx) {
    const child_ctx = ctx.slice();
    const constants_0 = JSON.parse(
      /*propItem*/
      child_ctx[1].note
    );
    child_ctx[19] = constants_0;
    return child_ctx;
  }
  function get_each_context_3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[20] = list[i];
    return child_ctx;
  }
  function get_each_context_4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[23] = list[i];
    return child_ctx;
  }
  function create_else_block_2(ctx) {
    let div;
    let icon;
    let t0;
    let span;
    let current;
    icon = new Icon_default({
      props: {
        size: 40,
        color: "#475569",
        src: FaSolidImage
      }
    });
    return {
      c() {
        div = element("div");
        create_component(icon.$.fragment);
        t0 = space();
        span = element("span");
        span.textContent = "No Image !";
        attr(span, "class", "svelte-rlah51");
        attr(div, "class", "image_empty svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(icon, div, null);
        append(div, t0);
        append(div, span);
        current = true;
      },
      p: noop,
      i(local) {
        if (current)
          return;
        transition_in(icon.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(icon.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(icon);
      }
    };
  }
  function create_if_block_15(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = String(
          /*propItem*/
          ctx[1].images[0]
        ).split(" ")[0]))
          attr(img, "src", img_src_value);
        attr(img, "alt", "");
        attr(img, "class", "svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && !src_url_equal(img.src, img_src_value = String(
          /*propItem*/
          ctx2[1].images[0]
        ).split(" ")[0])) {
          attr(img, "src", img_src_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  function create_if_block_14(ctx) {
    let span;
    let t_value = (
      /*s*/
      ctx[23].sign + " Property is " + /*s*/
      ctx[23].status
    );
    let t;
    let span_class_value;
    return {
      c() {
        span = element("span");
        t = text(t_value);
        attr(span, "class", span_class_value = null_to_empty(`prop_status ${/*s*/
        ctx[23].status}`) + " svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  function create_each_block_4(ctx) {
    let if_block_anchor;
    let if_block = (
      /*s*/
      ctx[23].status === /*approvalStatus*/
      ctx[5] && /*s*/
      ctx[23].status !== "approved" && create_if_block_14(ctx)
    );
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (
          /*s*/
          ctx2[23].status === /*approvalStatus*/
          ctx2[5] && /*s*/
          ctx2[23].status !== "approved"
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_14(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block)
          if_block.d(detaching);
      }
    };
  }
  function create_else_block_1(ctx) {
    let b;
    let t0_value = (
      /*propItem*/
      (ctx[1].sizeM2 || "0") + ""
    );
    let t0;
    let t1;
    return {
      c() {
        b = element("b");
        t0 = text(t0_value);
        t1 = text(" M2");
        attr(b, "class", "svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, b, anchor);
        append(b, t0);
        append(b, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && t0_value !== (t0_value = /*propItem*/
        (ctx2[1].sizeM2 || "0") + ""))
          set_data(t0, t0_value);
      },
      d(detaching) {
        if (detaching) {
          detach(b);
        }
      }
    };
  }
  function create_if_block_13(ctx) {
    let b;
    let t0_value = (void 0)(
      /*propItem*/
      ctx[1].sizeM2 || 0
    ) + "";
    let t0;
    let t1;
    return {
      c() {
        b = element("b");
        t0 = text(t0_value);
        t1 = text(" Ping");
        attr(b, "class", "svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, b, anchor);
        append(b, t0);
        append(b, t1);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && t0_value !== (t0_value = (void 0)(
          /*propItem*/
          ctx2[1].sizeM2 || 0
        ) + ""))
          set_data(t0, t0_value);
      },
      d(detaching) {
        if (detaching) {
          detach(b);
        }
      }
    };
  }
  function create_if_block_10(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_11, create_if_block_12];
    const if_blocks = [];
    function select_block_type_4(ctx2, dirty) {
      if (
        /*m*/
        ctx2[20].inputType === "datetime"
      )
        return 0;
      if (
        /*m*/
        ctx2[20].name !== "note"
      )
        return 1;
      return -1;
    }
    if (~(current_block_type_index = select_block_type_4(ctx, -1))) {
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    }
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].m(target, anchor);
        }
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_4(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if (~current_block_type_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          }
        } else {
          if (if_block) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
          }
          if (~current_block_type_index) {
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          } else {
            if_block = null;
          }
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].d(detaching);
        }
      }
    };
  }
  function create_if_block_5(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_6, create_if_block_7];
    const if_blocks = [];
    function select_block_type_3(ctx2, dirty) {
      if (
        /*m*/
        ctx2[20].inputType === "datetime"
      )
        return 0;
      if (
        /*m*/
        ctx2[20].name !== "note"
      )
        return 1;
      return -1;
    }
    if (~(current_block_type_index = select_block_type_3(ctx, -1))) {
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    }
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].m(target, anchor);
        }
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_3(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if (~current_block_type_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          }
        } else {
          if (if_block) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
          }
          if (~current_block_type_index) {
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          } else {
            if_block = null;
          }
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].d(detaching);
        }
      }
    };
  }
  function create_if_block_12(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[20].label
        ),
        content: (
          /*propItem*/
          ctx[1][
            /*m*/
            ctx[20].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[20].label;
        if (dirty & /*propItem, meta*/
        6)
          pillbox_changes.content = /*propItem*/
          ctx2[1][
            /*m*/
            ctx2[20].name
          ];
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_if_block_11(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[20].label
        ),
        content: (void 0)(
          /*propItem*/
          ctx[1][
            /*m*/
            ctx[20].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[20].label;
        if (dirty & /*propItem, meta*/
        6)
          pillbox_changes.content = (void 0)(
            /*propItem*/
            ctx2[1][
              /*m*/
              ctx2[20].name
            ]
          );
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_if_block_7(ctx) {
    let pillbox;
    let t0;
    let t1;
    let if_block1_anchor;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[20].label
        ),
        content: (
          /*propItem*/
          ctx[1][
            /*m*/
            ctx[20].name
          ]
        )
      }
    });
    let if_block0 = (
      /*facilityInfoJSON*/
      ctx[6][
        /*m*/
        ctx[20].name
      ] != `` && create_if_block_9(ctx)
    );
    let if_block1 = (
      /*mlsDisclaimerInfo*/
      ctx[7][
        /*m*/
        ctx[20].name
      ] != `` && create_if_block_8(ctx)
    );
    return {
      c() {
        create_component(pillbox.$.fragment);
        t0 = space();
        if (if_block0)
          if_block0.c();
        t1 = space();
        if (if_block1)
          if_block1.c();
        if_block1_anchor = empty();
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        insert(target, t0, anchor);
        if (if_block0)
          if_block0.m(target, anchor);
        insert(target, t1, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert(target, if_block1_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[20].label;
        if (dirty & /*propItem, meta*/
        6)
          pillbox_changes.content = /*propItem*/
          ctx2[1][
            /*m*/
            ctx2[20].name
          ];
        pillbox.$set(pillbox_changes);
        if (
          /*facilityInfoJSON*/
          ctx2[6][
            /*m*/
            ctx2[20].name
          ] != ``
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
            if (dirty & /*facilityInfoJSON, meta*/
            68) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_9(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t1.parentNode, t1);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (
          /*mlsDisclaimerInfo*/
          ctx2[7][
            /*m*/
            ctx2[20].name
          ] != ``
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty & /*mlsDisclaimerInfo, meta*/
            132) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_8(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        transition_in(if_block0);
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        transition_out(if_block0);
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(t1);
          detach(if_block1_anchor);
        }
        destroy_component(pillbox, detaching);
        if (if_block0)
          if_block0.d(detaching);
        if (if_block1)
          if_block1.d(detaching);
      }
    };
  }
  function create_if_block_6(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[20].label
        ),
        content: (void 0)(
          /*propItem*/
          ctx[1][
            /*m*/
            ctx[20].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[20].label;
        if (dirty & /*propItem, meta*/
        6)
          pillbox_changes.content = (void 0)(
            /*propItem*/
            ctx2[1][
              /*m*/
              ctx2[20].name
            ]
          );
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_if_block_9(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[20].label
        ),
        content: (
          /*facilityInfoJSON*/
          ctx[6][
            /*m*/
            ctx[20].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[20].label;
        if (dirty & /*facilityInfoJSON, meta*/
        68)
          pillbox_changes.content = /*facilityInfoJSON*/
          ctx2[6][
            /*m*/
            ctx2[20].name
          ];
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_if_block_8(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[20].label
        ),
        content: (
          /*mlsDisclaimerInfo*/
          ctx[7][
            /*m*/
            ctx[20].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[20].label;
        if (dirty & /*mlsDisclaimerInfo, meta*/
        132)
          pillbox_changes.content = /*mlsDisclaimerInfo*/
          ctx2[7][
            /*m*/
            ctx2[20].name
          ];
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_each_block_3(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_5, create_if_block_10];
    const if_blocks = [];
    function select_block_type_2(ctx2, dirty) {
      if (!/*isAdmin*/
      ctx2[3] && !/*m*/
      (ctx2[20].name === "createdAt" || /*m*/
      ctx2[20].name === "updatedAt" || /*m*/
      ctx2[20].name === "countryCode"))
        return 0;
      if (
        /*isAdmin*/
        ctx2[3]
      )
        return 1;
      return -1;
    }
    if (~(current_block_type_index = select_block_type_2(ctx, -1))) {
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    }
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].m(target, anchor);
        }
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_2(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if (~current_block_type_index) {
            if_blocks[current_block_type_index].p(ctx2, dirty);
          }
        } else {
          if (if_block) {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
          }
          if (~current_block_type_index) {
            if_block = if_blocks[current_block_type_index];
            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
              if_block.c();
            } else {
              if_block.p(ctx2, dirty);
            }
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          } else {
            if_block = null;
          }
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].d(detaching);
        }
      }
    };
  }
  function create_if_block_4(ctx) {
    let pillbox0;
    let t0;
    let pillbox1;
    let t1;
    let pillbox2;
    let current;
    pillbox0 = new PillBox_default({
      props: {
        label: "About",
        content: (
          /*note*/
          ctx[19].about
        )
      }
    });
    pillbox1 = new PillBox_default({
      props: {
        label: "Seller/Broker Email",
        content: (
          /*note*/
          ctx[19].contactEmail
        )
      }
    });
    pillbox2 = new PillBox_default({
      props: {
        label: "Seller/Broker Phone",
        content: (
          /*note*/
          ctx[19].contactPhone
        )
      }
    });
    return {
      c() {
        create_component(pillbox0.$.fragment);
        t0 = space();
        create_component(pillbox1.$.fragment);
        t1 = space();
        create_component(pillbox2.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox0, target, anchor);
        insert(target, t0, anchor);
        mount_component(pillbox1, target, anchor);
        insert(target, t1, anchor);
        mount_component(pillbox2, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox0_changes = {};
        if (dirty & /*propItem*/
        2)
          pillbox0_changes.content = /*note*/
          ctx2[19].about;
        pillbox0.$set(pillbox0_changes);
        const pillbox1_changes = {};
        if (dirty & /*propItem*/
        2)
          pillbox1_changes.content = /*note*/
          ctx2[19].contactEmail;
        pillbox1.$set(pillbox1_changes);
        const pillbox2_changes = {};
        if (dirty & /*propItem*/
        2)
          pillbox2_changes.content = /*note*/
          ctx2[19].contactPhone;
        pillbox2.$set(pillbox2_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox0.$.fragment, local);
        transition_in(pillbox1.$.fragment, local);
        transition_in(pillbox2.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox0.$.fragment, local);
        transition_out(pillbox1.$.fragment, local);
        transition_out(pillbox2.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(t1);
        }
        destroy_component(pillbox0, detaching);
        destroy_component(pillbox1, detaching);
        destroy_component(pillbox2, detaching);
      }
    };
  }
  function create_if_block_1(ctx) {
    let div1;
    let h3;
    let t1;
    let div0;
    let current;
    let each_value_1 = ensure_array_like(
      /*propItem*/
      ctx[1].floorList
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    });
    return {
      c() {
        div1 = element("div");
        h3 = element("h3");
        h3.textContent = "Floors";
        t1 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h3, "class", "svelte-rlah51");
        attr(div0, "class", "floor_lists svelte-rlah51");
        attr(div1, "class", "property_floors svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h3);
        append(div1, t1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2) {
          each_value_1 = ensure_array_like(
            /*propItem*/
            ctx2[1].floorList
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_1(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value_1.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        for (let i = 0; i < each_value_1.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_if_block_3(ctx) {
    let div;
    let each_value_2 = ensure_array_like(
      /*floors*/
      ctx[13].rooms
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "room_lists svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2) {
          each_value_2 = ensure_array_like(
            /*floors*/
            ctx2[13].rooms
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2(ctx2, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_2(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_2.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block_2(ctx) {
    let div;
    let span0;
    let t0_value = (
      /*room*/
      (ctx[16].name || "-") + ""
    );
    let t0;
    let t1;
    let span1;
    let t2_value = (
      /*room*/
      (ctx[16].sizeM2 || "-") + ""
    );
    let t2;
    let t3;
    let t4;
    return {
      c() {
        div = element("div");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = text(t2_value);
        t3 = text(" M2");
        t4 = space();
        attr(div, "class", "room_item svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span0);
        append(span0, t0);
        append(div, t1);
        append(div, span1);
        append(span1, t2);
        append(span1, t3);
        append(div, t4);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && t0_value !== (t0_value = /*room*/
        (ctx2[16].name || "-") + ""))
          set_data(t0, t0_value);
        if (dirty & /*propItem*/
        2 && t2_value !== (t2_value = /*room*/
        (ctx2[16].sizeM2 || "-") + ""))
          set_data(t2, t2_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_else_block(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*floors*/
        ctx[13].planImageUrl))
          attr(img, "src", img_src_value);
        attr(img, "alt", "");
        attr(img, "class", "svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && !src_url_equal(img.src, img_src_value = /*floors*/
        ctx2[13].planImageUrl)) {
          attr(img, "src", img_src_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  function create_if_block_2(ctx) {
    let div;
    let icon;
    let t0;
    let span;
    let current;
    icon = new Icon_default({
      props: {
        size: 30,
        color: "#475569",
        src: FaSolidImage
      }
    });
    return {
      c() {
        div = element("div");
        create_component(icon.$.fragment);
        t0 = space();
        span = element("span");
        span.textContent = "No Image !";
        attr(div, "class", "image_empty svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(icon, div, null);
        append(div, t0);
        append(div, span);
        current = true;
      },
      p: noop,
      i(local) {
        if (current)
          return;
        transition_in(icon.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(icon.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(icon);
      }
    };
  }
  function create_each_block_1(ctx) {
    let div2;
    let div0;
    let h5;
    let t0_value = (
      /*floors*/
      ctx[13].type === "basement" ? "Basement" : `Floor #${/*floors*/
      ctx[13].floor}`
    );
    let t0;
    let t1;
    let c;
    let t2;
    let t3;
    let div1;
    let current_block_type_index;
    let if_block1;
    let t4;
    let current;
    let if_block0 = (
      /*floors*/
      ctx[13].rooms && create_if_block_3(ctx)
    );
    const if_block_creators = [create_if_block_2, create_else_block];
    const if_blocks = [];
    function select_block_type_5(ctx2, dirty) {
      if (
        /*floors*/
        ctx2[13].planImageUrl === ""
      )
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type_5(ctx, -1);
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        h5 = element("h5");
        t0 = text(t0_value);
        t1 = space();
        c = comment(" TODO: currently room list only 1 object, fix Tarantool to accept array ");
        t2 = space();
        if (if_block0)
          if_block0.c();
        t3 = space();
        div1 = element("div");
        if_block1.c();
        t4 = space();
        attr(h5, "class", "svelte-rlah51");
        attr(div0, "class", "left svelte-rlah51");
        attr(div1, "class", "floor_plan_image svelte-rlah51");
        attr(div2, "class", "floor_item svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div0, h5);
        append(h5, t0);
        append(div0, t1);
        append(div0, c);
        append(div0, t2);
        if (if_block0)
          if_block0.m(div0, null);
        append(div2, t3);
        append(div2, div1);
        if_blocks[current_block_type_index].m(div1, null);
        append(div2, t4);
        current = true;
      },
      p(ctx2, dirty) {
        if ((!current || dirty & /*propItem*/
        2) && t0_value !== (t0_value = /*floors*/
        ctx2[13].type === "basement" ? "Basement" : `Floor #${/*floors*/
        ctx2[13].floor}`))
          set_data(t0, t0_value);
        if (
          /*floors*/
          ctx2[13].rooms
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_3(ctx2);
            if_block0.c();
            if_block0.m(div0, null);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_5(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if (if_block0)
          if_block0.d();
        if_blocks[current_block_type_index].d();
      }
    };
  }
  function create_if_block2(ctx) {
    let div1;
    let h3;
    let t1;
    let div0;
    let each_value = ensure_array_like(
      /*propHistories*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        h3 = element("h3");
        h3.textContent = "Price History";
        t1 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h3, "class", "svelte-rlah51");
        attr(div0, "class", "history_list svelte-rlah51");
        attr(div1, "class", "property_history svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h3);
        append(div1, t1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*propHistories*/
        1) {
          each_value = ensure_array_like(
            /*propHistories*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block(ctx) {
    let div;
    let span0;
    let t0_value = (void 0)(
      /*ph*/
      ctx[10].price || /*ph*/
      ctx[10].priceNtd,
      "TWD"
    ) + "";
    let t0;
    let t1;
    let span1;
    let t2_value = (void 0)(
      /*ph*/
      ctx[10].updatedAt
    ) + "";
    let t2;
    let t3;
    return {
      c() {
        div = element("div");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = text(t2_value);
        t3 = space();
        attr(div, "class", "item svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span0);
        append(span0, t0);
        append(div, t1);
        append(div, span1);
        append(span1, t2);
        append(div, t3);
      },
      p(ctx2, dirty) {
        if (dirty & /*propHistories*/
        1 && t0_value !== (t0_value = (void 0)(
          /*ph*/
          ctx2[10].price || /*ph*/
          ctx2[10].priceNtd,
          "TWD"
        ) + ""))
          set_data(t0, t0_value);
        if (dirty & /*propHistories*/
        1 && t2_value !== (t2_value = (void 0)(
          /*ph*/
          ctx2[10].updatedAt
        ) + ""))
          set_data(t2, t2_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_fragment3(ctx) {
    let div16;
    let div8;
    let div0;
    let current_block_type_index;
    let if_block0;
    let t0;
    let div7;
    let div4;
    let div3;
    let div1;
    let t1_value = (
      /*propItem*/
      ctx[1].purpose === "rent" ? "For Rent" : "On Sale"
    );
    let t1;
    let div1_class_value;
    let t2;
    let div2;
    let icon0;
    let t3;
    let span0;
    let t4_value = (
      /*propItem*/
      (ctx[1].houseType === "" ? "House" : (
        /*propItem*/
        ctx[1].houseType
      )) + ""
    );
    let t4;
    let t5;
    let t6;
    let div6;
    let h1;
    let t7_value = ((void 0)(
      /*propItem*/
      ctx[1].lastPrice,
      "TWD"
    ) || "0.00") + "";
    let t7;
    let t8;
    let p0;
    let t9;
    let t10_value = (
      /*propItem*/
      ctx[1].agencyFeePercent + ""
    );
    let t10;
    let t11;
    let t12;
    let div5;
    let icon1;
    let t13;
    let span1;
    let t14_value = (
      /*propItem*/
      (ctx[1].formattedAddress === "" ? (
        /*propItem*/
        ctx[1].address
      ) : (
        /*propItem*/
        ctx[1].formattedAddress
      )) + ""
    );
    let t14;
    let t15;
    let div14;
    let div13;
    let div9;
    let b0;
    let t16_value = (
      /*propItem*/
      (ctx[1].numberOfFloors || "0") + ""
    );
    let t16;
    let t17;
    let p1;
    let t19;
    let div10;
    let b1;
    let t20_value = (
      /*propItem*/
      (ctx[1].bathroom || "0") + ""
    );
    let t20;
    let t21;
    let p2;
    let t23;
    let div11;
    let b2;
    let t24_value = (
      /*propItem*/
      (ctx[1].bedroom || "0") + ""
    );
    let t24;
    let t25;
    let p3;
    let t27;
    let div12;
    let t28;
    let p4;
    let t30;
    let div15;
    let t31;
    let t32;
    let t33;
    let current;
    const if_block_creators = [create_if_block_15, create_else_block_2];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*propItem*/
        ctx2[1].images && /*propItem*/
        ctx2[1].images.length
      )
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx, -1);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    icon0 = new Icon_default({
      props: {
        color: "#FFF",
        size: 16,
        src: FaSolidHouse
      }
    });
    let each_value_4 = ensure_array_like(
      /*signs*/
      ctx[8]
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_4.length; i += 1) {
      each_blocks_1[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    }
    icon1 = new Icon_default({
      props: {
        className: "icon_address",
        color: "#f97316",
        size: 18,
        src: FaSolidMapLocationDot
      }
    });
    function select_block_type_1(ctx2, dirty) {
      if (
        /*propItem*/
        ctx2[1].countryCode === "TW" || /*propItem*/
        ctx2[1].countryCode === ""
      )
        return create_if_block_13;
      return create_else_block_1;
    }
    let current_block_type = select_block_type_1(ctx, -1);
    let if_block1 = current_block_type(ctx);
    let each_value_3 = ensure_array_like(
      /*meta*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_3.length; i += 1) {
      each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    }
    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    });
    let if_block2 = !/*isGuest*/
    ctx[4] && /*propItem*/
    ctx[1].note && create_if_block_4(get_if_ctx(ctx));
    let if_block3 = (
      /*propItem*/
      ctx[1].floorList && /*propItem*/
      ctx[1].floorList.length && create_if_block_1(ctx)
    );
    let if_block4 = (
      /*propHistories*/
      ctx[0] && /*propHistories*/
      ctx[0].length && create_if_block2(ctx)
    );
    return {
      c() {
        div16 = element("div");
        div8 = element("div");
        div0 = element("div");
        if_block0.c();
        t0 = space();
        div7 = element("div");
        div4 = element("div");
        div3 = element("div");
        div1 = element("div");
        t1 = text(t1_value);
        t2 = space();
        div2 = element("div");
        create_component(icon0.$.fragment);
        t3 = space();
        span0 = element("span");
        t4 = text(t4_value);
        t5 = space();
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t6 = space();
        div6 = element("div");
        h1 = element("h1");
        t7 = text(t7_value);
        t8 = space();
        p0 = element("p");
        t9 = text("Agency Fee : ");
        t10 = text(t10_value);
        t11 = text("%");
        t12 = space();
        div5 = element("div");
        create_component(icon1.$.fragment);
        t13 = space();
        span1 = element("span");
        t14 = text(t14_value);
        t15 = space();
        div14 = element("div");
        div13 = element("div");
        div9 = element("div");
        b0 = element("b");
        t16 = text(t16_value);
        t17 = space();
        p1 = element("p");
        p1.textContent = "Floors";
        t19 = space();
        div10 = element("div");
        b1 = element("b");
        t20 = text(t20_value);
        t21 = space();
        p2 = element("p");
        p2.textContent = "Baths";
        t23 = space();
        div11 = element("div");
        b2 = element("b");
        t24 = text(t24_value);
        t25 = space();
        p3 = element("p");
        p3.textContent = "Beds";
        t27 = space();
        div12 = element("div");
        if_block1.c();
        t28 = space();
        p4 = element("p");
        p4.textContent = "Size";
        t30 = space();
        div15 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t31 = space();
        if (if_block2)
          if_block2.c();
        t32 = space();
        if (if_block3)
          if_block3.c();
        t33 = space();
        if (if_block4)
          if_block4.c();
        attr(div0, "class", "property_images svelte-rlah51");
        attr(div1, "class", div1_class_value = null_to_empty(
          /*propItem*/
          ctx[1].purpose === "rent" ? `purpose label_rent` : `purpose label_sale`
        ) + " svelte-rlah51");
        attr(span0, "class", "svelte-rlah51");
        attr(div2, "class", "house_type svelte-rlah51");
        attr(div3, "class", "left svelte-rlah51");
        attr(div4, "class", "col1 svelte-rlah51");
        attr(h1, "class", "svelte-rlah51");
        attr(p0, "class", "svelte-rlah51");
        attr(span1, "class", "svelte-rlah51");
        attr(div5, "class", "address svelte-rlah51");
        attr(div6, "class", "col2 svelte-rlah51");
        attr(div7, "class", "property_info svelte-rlah51");
        attr(div8, "class", "property_main svelte-rlah51");
        attr(b0, "class", "svelte-rlah51");
        attr(p1, "class", "svelte-rlah51");
        attr(div9, "class", "feature_item svelte-rlah51");
        attr(b1, "class", "svelte-rlah51");
        attr(p2, "class", "svelte-rlah51");
        attr(div10, "class", "feature_item svelte-rlah51");
        attr(b2, "class", "svelte-rlah51");
        attr(p3, "class", "svelte-rlah51");
        attr(div11, "class", "feature_item svelte-rlah51");
        attr(p4, "class", "svelte-rlah51");
        attr(div12, "class", "feature_item svelte-rlah51");
        attr(div13, "class", "feature_number svelte-rlah51");
        attr(div14, "class", "property_secondary svelte-rlah51");
        attr(div15, "class", "property_attributes");
        attr(div16, "class", "property svelte-rlah51");
      },
      m(target, anchor) {
        insert(target, div16, anchor);
        append(div16, div8);
        append(div8, div0);
        if_blocks[current_block_type_index].m(div0, null);
        append(div8, t0);
        append(div8, div7);
        append(div7, div4);
        append(div4, div3);
        append(div3, div1);
        append(div1, t1);
        append(div3, t2);
        append(div3, div2);
        mount_component(icon0, div2, null);
        append(div2, t3);
        append(div2, span0);
        append(span0, t4);
        append(div4, t5);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div4, null);
          }
        }
        append(div7, t6);
        append(div7, div6);
        append(div6, h1);
        append(h1, t7);
        append(div6, t8);
        append(div6, p0);
        append(p0, t9);
        append(p0, t10);
        append(p0, t11);
        append(div6, t12);
        append(div6, div5);
        mount_component(icon1, div5, null);
        append(div5, t13);
        append(div5, span1);
        append(span1, t14);
        append(div16, t15);
        append(div16, div14);
        append(div14, div13);
        append(div13, div9);
        append(div9, b0);
        append(b0, t16);
        append(div9, t17);
        append(div9, p1);
        append(div13, t19);
        append(div13, div10);
        append(div10, b1);
        append(b1, t20);
        append(div10, t21);
        append(div10, p2);
        append(div13, t23);
        append(div13, div11);
        append(div11, b2);
        append(b2, t24);
        append(div11, t25);
        append(div11, p3);
        append(div13, t27);
        append(div13, div12);
        if_block1.m(div12, null);
        append(div12, t28);
        append(div12, p4);
        append(div16, t30);
        append(div16, div15);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div15, null);
          }
        }
        append(div15, t31);
        if (if_block2)
          if_block2.m(div15, null);
        append(div16, t32);
        if (if_block3)
          if_block3.m(div16, null);
        append(div16, t33);
        if (if_block4)
          if_block4.m(div16, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
        if ((!current || dirty & /*propItem*/
        2) && t1_value !== (t1_value = /*propItem*/
        ctx2[1].purpose === "rent" ? "For Rent" : "On Sale"))
          set_data(t1, t1_value);
        if (!current || dirty & /*propItem*/
        2 && div1_class_value !== (div1_class_value = null_to_empty(
          /*propItem*/
          ctx2[1].purpose === "rent" ? `purpose label_rent` : `purpose label_sale`
        ) + " svelte-rlah51")) {
          attr(div1, "class", div1_class_value);
        }
        if ((!current || dirty & /*propItem*/
        2) && t4_value !== (t4_value = /*propItem*/
        (ctx2[1].houseType === "" ? "House" : (
          /*propItem*/
          ctx2[1].houseType
        )) + ""))
          set_data(t4, t4_value);
        if (dirty & /*signs, approvalStatus*/
        288) {
          each_value_4 = ensure_array_like(
            /*signs*/
            ctx2[8]
          );
          let i;
          for (i = 0; i < each_value_4.length; i += 1) {
            const child_ctx = get_each_context_4(ctx2, each_value_4, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_4(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div4, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_4.length;
        }
        if ((!current || dirty & /*propItem*/
        2) && t7_value !== (t7_value = ((void 0)(
          /*propItem*/
          ctx2[1].lastPrice,
          "TWD"
        ) || "0.00") + ""))
          set_data(t7, t7_value);
        if ((!current || dirty & /*propItem*/
        2) && t10_value !== (t10_value = /*propItem*/
        ctx2[1].agencyFeePercent + ""))
          set_data(t10, t10_value);
        if ((!current || dirty & /*propItem*/
        2) && t14_value !== (t14_value = /*propItem*/
        (ctx2[1].formattedAddress === "" ? (
          /*propItem*/
          ctx2[1].address
        ) : (
          /*propItem*/
          ctx2[1].formattedAddress
        )) + ""))
          set_data(t14, t14_value);
        if ((!current || dirty & /*propItem*/
        2) && t16_value !== (t16_value = /*propItem*/
        (ctx2[1].numberOfFloors || "0") + ""))
          set_data(t16, t16_value);
        if ((!current || dirty & /*propItem*/
        2) && t20_value !== (t20_value = /*propItem*/
        (ctx2[1].bathroom || "0") + ""))
          set_data(t20, t20_value);
        if ((!current || dirty & /*propItem*/
        2) && t24_value !== (t24_value = /*propItem*/
        (ctx2[1].bedroom || "0") + ""))
          set_data(t24, t24_value);
        if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1.d(1);
          if_block1 = current_block_type(ctx2);
          if (if_block1) {
            if_block1.c();
            if_block1.m(div12, t28);
          }
        }
        if (dirty & /*meta, propItem, mlsDisclaimerInfo, facilityInfoJSON, isAdmin*/
        206) {
          each_value_3 = ensure_array_like(
            /*meta*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value_3.length; i += 1) {
            const child_ctx = get_each_context_3(ctx2, each_value_3, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_3(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div15, t31);
            }
          }
          group_outros();
          for (i = each_value_3.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (!/*isGuest*/
        ctx2[4] && /*propItem*/
        ctx2[1].note) {
          if (if_block2) {
            if_block2.p(get_if_ctx(ctx2), dirty);
            if (dirty & /*isGuest, propItem*/
            18) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block_4(get_if_ctx(ctx2));
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(div15, null);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
        if (
          /*propItem*/
          ctx2[1].floorList && /*propItem*/
          ctx2[1].floorList.length
        ) {
          if (if_block3) {
            if_block3.p(ctx2, dirty);
            if (dirty & /*propItem*/
            2) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block_1(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(div16, t33);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
        if (
          /*propHistories*/
          ctx2[0] && /*propHistories*/
          ctx2[0].length
        ) {
          if (if_block4) {
            if_block4.p(ctx2, dirty);
          } else {
            if_block4 = create_if_block2(ctx2);
            if_block4.c();
            if_block4.m(div16, null);
          }
        } else if (if_block4) {
          if_block4.d(1);
          if_block4 = null;
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block0);
        transition_in(icon0.$.fragment, local);
        transition_in(icon1.$.fragment, local);
        for (let i = 0; i < each_value_3.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(if_block2);
        transition_in(if_block3);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        transition_out(icon0.$.fragment, local);
        transition_out(icon1.$.fragment, local);
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(if_block2);
        transition_out(if_block3);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div16);
        }
        if_blocks[current_block_type_index].d();
        destroy_component(icon0);
        destroy_each(each_blocks_1, detaching);
        destroy_component(icon1);
        if_block1.d();
        destroy_each(each_blocks, detaching);
        if (if_block2)
          if_block2.d();
        if (if_block3)
          if_block3.d();
        if (if_block4)
          if_block4.d();
      }
    };
  }
  function instance3($self, $props, $invalidate) {
    let { propHistories } = $props;
    let { propItem = (
      /** @type {TypeProperty | TypePropertyUS} */
      {}
    ) } = $props;
    let { meta } = $props;
    let { isAdmin: isAdmin2 = false } = $props;
    let { isGuest = false } = $props;
    let { propExtraUS = (
      /** @type {TypePropertyExtraUS} */
      {}
    ) } = $props;
    let approvalStatus = "approved";
    let signs = [
      { status: "approved", sign: "***" },
      { status: "rejected", sign: "**" },
      { status: "pending", sign: "*" }
    ];
    let facilityInfoJSON;
    let mlsDisclaimerInfo;
    try {
      facilityInfoJSON = JSON.parse(String(propExtraUS.facilityInfo));
      mlsDisclaimerInfo = JSON.parse(String(propExtraUS.mlsDisclaimerInfo));
    } catch (error) {
      facilityInfoJSON = {};
      mlsDisclaimerInfo = {};
    }
    onMount(() => {
      console.log("onMount.Property");
      console.log("Property = ", propItem);
      console.log("Meta =", meta);
      console.log("IsAdmin =", isAdmin2);
      console.log("isGuest =", isGuest);
      console.log("propItem.note =", propItem.note);
      if (propItem.approvalState !== "pending" && propItem.approvalState !== "") {
        $invalidate(5, approvalStatus = "rejected");
      }
      if (propItem.approvalState === "pending") {
        $invalidate(5, approvalStatus = "pending");
      }
    });
    $self.$set = ($props2) => {
      if ("propHistories" in $props2)
        $invalidate(0, propHistories = $props2.propHistories);
      if ("propItem" in $props2)
        $invalidate(1, propItem = $props2.propItem);
      if ("meta" in $props2)
        $invalidate(2, meta = $props2.meta);
      if ("isAdmin" in $props2)
        $invalidate(3, isAdmin2 = $props2.isAdmin);
      if ("isGuest" in $props2)
        $invalidate(4, isGuest = $props2.isGuest);
      if ("propExtraUS" in $props2)
        $invalidate(9, propExtraUS = $props2.propExtraUS);
    };
    return [
      propHistories,
      propItem,
      meta,
      isAdmin2,
      isGuest,
      approvalStatus,
      facilityInfoJSON,
      mlsDisclaimerInfo,
      signs,
      propExtraUS
    ];
  }
  var Property = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment3, safe_not_equal, {
        propHistories: 0,
        propItem: 1,
        meta: 2,
        isAdmin: 3,
        isGuest: 4,
        propExtraUS: 9
      });
    }
  };
  var Property_default = Property;

  // user/property/index.svelte
  function create_else_block2(ctx) {
    let div0;
    let property;
    let t0;
    let div5;
    let div2;
    let div1;
    let t4;
    let a0;
    let span0;
    let t6;
    let icon0;
    let t7;
    let div4;
    let header;
    let span1;
    let t9;
    let icon1;
    let t10;
    let div3;
    let button;
    let icon2;
    let t11;
    let a1;
    let icon3;
    let a1_href_value;
    let t12;
    let a2;
    let icon4;
    let a2_href_value;
    let t13;
    let a3;
    let icon5;
    let a3_href_value;
    let t14;
    let a4;
    let icon6;
    let a4_href_value;
    let t15;
    let a5;
    let icon7;
    let a5_href_value;
    let current;
    let mounted;
    let dispose;
    property = new Property_default({
      props: {
        propItem: (
          /*propItem*/
          ctx[1]
        ),
        meta: (
          /*meta*/
          ctx[2]
        ),
        propHistories: (
          /*propHistories*/
          ctx[0]
        ),
        isAdmin
      }
    });
    icon0 = new Icon_default({
      props: {
        color: "#FFF",
        size: 13,
        src: FaSolidArrowRight
      }
    });
    icon1 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#9fa9b5",
        size: 14,
        src: FaSolidShareNodes
      }
    });
    icon2 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 28,
        src: FaCopy
      }
    });
    icon3 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsFacebook
      }
    });
    icon4 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsLinkedin
      }
    });
    icon5 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsTwitter
      }
    });
    icon6 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsTelegram
      }
    });
    icon7 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 33,
        src: FaBrandsWhatsapp
      }
    });
    return {
      c() {
        div0 = element("div");
        create_component(property.$.fragment);
        t0 = space();
        div5 = element("div");
        div2 = element("div");
        div1 = element("div");
        div1.innerHTML = `<h3 class="svelte-2tq1rc">Login to</h3> <h3 class="svelte-2tq1rc">HapSTR</h3>`;
        t4 = space();
        a0 = element("a");
        span0 = element("span");
        span0.textContent = "Login";
        t6 = space();
        create_component(icon0.$.fragment);
        t7 = space();
        div4 = element("div");
        header = element("header");
        span1 = element("span");
        span1.textContent = "Share this";
        t9 = space();
        create_component(icon1.$.fragment);
        t10 = space();
        div3 = element("div");
        button = element("button");
        create_component(icon2.$.fragment);
        t11 = space();
        a1 = element("a");
        create_component(icon3.$.fragment);
        t12 = space();
        a2 = element("a");
        create_component(icon4.$.fragment);
        t13 = space();
        a3 = element("a");
        create_component(icon5.$.fragment);
        t14 = space();
        a4 = element("a");
        create_component(icon6.$.fragment);
        t15 = space();
        a5 = element("a");
        create_component(icon7.$.fragment);
        attr(div0, "class", "property svelte-2tq1rc");
        attr(a0, "class", "login_btn svelte-2tq1rc");
        attr(a0, "href", "/");
        attr(div2, "class", "login_container svelte-2tq1rc");
        attr(header, "class", "svelte-2tq1rc");
        attr(button, "class", "share_item svelte-2tq1rc");
        attr(button, "title", "Copy link address");
        attr(a1, "aria-label", "Share to Facebook");
        attr(a1, "class", "share_item svelte-2tq1rc");
        attr(a1, "href", a1_href_value = "https://www.facebook.com/sharer/sharer.php?u=" + /*toBeUrl*/
        ctx[3] + "?utm_source=facebook&utm_medium=social&utm_campaign=user-share");
        attr(a1, "rel", "noopener");
        attr(a1, "target", "_blank");
        attr(a2, "aria-label", "Share to LinkedIn");
        attr(a2, "class", "share_item svelte-2tq1rc");
        attr(a2, "href", a2_href_value = "https://www.linkedin.com/shareArticle?mini=true&url=" + /*toBeUrl*/
        ctx[3] + "&title=I%20Found%20Awesome%House%20" + window.location);
        attr(a2, "rel", "noopener");
        attr(a2, "target", "_blank");
        attr(a3, "aria-label", "Share to Twitter");
        attr(a3, "class", "share_item svelte-2tq1rc");
        attr(a3, "href", a3_href_value = "https://twitter.com/intent/tweet?url=" + /*toBeUrl*/
        ctx[3]);
        attr(a3, "rel", "noopener");
        attr(a3, "target", "_blank");
        attr(a4, "aria-label", "Share to Telegram");
        attr(a4, "class", "share_item svelte-2tq1rc");
        attr(a4, "href", a4_href_value = "https://t.me/share/url?url=" + /*toBeUrl*/
        ctx[3]);
        attr(a4, "rel", "noopener");
        attr(a4, "target", "_blank");
        attr(a5, "aria-label", "Share to WhatsApp");
        attr(a5, "class", "share_item svelte-2tq1rc");
        attr(a5, "href", a5_href_value = "https://api.whatsapp.com/send?text=I%20Found%20Awesome%20House%20" + /*toBeUrl*/
        ctx[3]);
        attr(a5, "rel", "noopener");
        attr(a5, "target", "_blank");
        attr(div3, "class", "share_options svelte-2tq1rc");
        attr(div4, "class", "share_container svelte-2tq1rc");
        attr(div5, "class", "side_attribute svelte-2tq1rc");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        mount_component(property, div0, null);
        insert(target, t0, anchor);
        insert(target, div5, anchor);
        append(div5, div2);
        append(div2, div1);
        append(div2, t4);
        append(div2, a0);
        append(a0, span0);
        append(a0, t6);
        mount_component(icon0, a0, null);
        append(div5, t7);
        append(div5, div4);
        append(div4, header);
        append(header, span1);
        append(header, t9);
        mount_component(icon1, header, null);
        append(div4, t10);
        append(div4, div3);
        append(div3, button);
        mount_component(icon2, button, null);
        append(div3, t11);
        append(div3, a1);
        mount_component(icon3, a1, null);
        append(div3, t12);
        append(div3, a2);
        mount_component(icon4, a2, null);
        append(div3, t13);
        append(div3, a3);
        mount_component(icon5, a3, null);
        append(div3, t14);
        append(div3, a4);
        mount_component(icon6, a4, null);
        append(div3, t15);
        append(div3, a5);
        mount_component(icon7, a5, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            button,
            "click",
            /*click_handler*/
            ctx[5]
          );
          mounted = true;
        }
      },
      p: noop,
      i(local) {
        if (current)
          return;
        transition_in(property.$.fragment, local);
        transition_in(icon0.$.fragment, local);
        transition_in(icon1.$.fragment, local);
        transition_in(icon2.$.fragment, local);
        transition_in(icon3.$.fragment, local);
        transition_in(icon4.$.fragment, local);
        transition_in(icon5.$.fragment, local);
        transition_in(icon6.$.fragment, local);
        transition_in(icon7.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(property.$.fragment, local);
        transition_out(icon0.$.fragment, local);
        transition_out(icon1.$.fragment, local);
        transition_out(icon2.$.fragment, local);
        transition_out(icon3.$.fragment, local);
        transition_out(icon4.$.fragment, local);
        transition_out(icon5.$.fragment, local);
        transition_out(icon6.$.fragment, local);
        transition_out(icon7.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div0);
          detach(t0);
          detach(div5);
        }
        destroy_component(property);
        destroy_component(icon0);
        destroy_component(icon1);
        destroy_component(icon2);
        destroy_component(icon3);
        destroy_component(icon4);
        destroy_component(icon5);
        destroy_component(icon6);
        destroy_component(icon7);
        mounted = false;
        dispose();
      }
    };
  }
  function create_if_block3(ctx) {
    let t;
    return {
      c() {
        t = text("this property has been deleted");
      },
      m(target, anchor) {
        insert(target, t, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(t);
        }
      }
    };
  }
  function create_fragment4(ctx) {
    let section;
    let current_block_type_index;
    let if_block;
    let current;
    const if_block_creators = [create_if_block3, create_else_block2];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*propItem*/
        ctx2[1].deletedAt > 0
      )
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx, -1);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        section = element("section");
        if_block.c();
        attr(section, "class", "property_container svelte-2tq1rc");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        if_blocks[current_block_type_index].m(section, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if_block.p(ctx2, dirty);
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(section);
        }
        if_blocks[current_block_type_index].d();
      }
    };
  }
  var isAdmin = false;
  function instance4($self) {
    let propHistories = [];
    let propItem = {};
    let meta = {};
    let showGrowl = false, gMsg = "", gType = "";
    onMount(() => {
      console.log("onMount.user/property/index");
      console.log("propHistories = ", propHistories);
    });
    function useGrowl(type, msg) {
      showGrowl = true;
      gMsg = msg;
      gType = type;
      setTimeout(
        () => {
          showGrowl = false;
        },
        2e3
      );
    }
    let url = window.location.pathname.split("user/");
    let toBeUrl = window.location.host + "/guest/" + url[1];
    function copyToClipboard(text2) {
      navigator.clipboard.writeText(text2);
      useGrowl("success", "Link copied to clipboard");
    }
    const click_handler = () => copyToClipboard(toBeUrl);
    return [propHistories, propItem, meta, toBeUrl, copyToClipboard, click_handler];
  }
  var Property_1 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment4, safe_not_equal, {});
    }
  };
  var property_default = Property_1;

  // user/property/index.svelte.ts
  var app = new property_default({ target: document.getElementById("app") });
})();
</script>
</body></html>