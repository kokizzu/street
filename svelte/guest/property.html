<html><head>
    <title>/*! title */</title>
    <link href="/css.gg.css" rel="stylesheet">
</head>
<body>
<style>
    *,
    *::before,
    *::after {
        box-sizing : border-box;
    }

    :root {
        -moz-tab-size : 4;
        -o-tab-size   : 4;
        tab-size      : 4;
    }

    html {
        max-width                : 100%;
        margin                   : auto;
        line-height-step         : 1.15;
        -webkit-text-size-adjust : 100%;
        font-size                : 13px;
    }

    body {
        font-family : Roboto, Helvetica, Arial, sans-serif;
        margin      : 0;
    }

    hr {
        height           : 0;
        border-top-width : 1px;
        width            : 100%;
        overflow         : hidden;
        color            : inherit;
        margin           : 0;
    }

    /* Dashboard */
    section.dashboard {
        display        : flex;
        flex-direction : row;
    }

    .dashboard_main_content {
        background-color : #F1F5F9;
        min-height       : 100vh;
        width            : 100%;
    }

    .dashboard_main_content .content {
        min-height : 900px;
    }


    .tableview_container {
        position         : relative;
        z-index          : 30;
        margin-top       : -40px;
        margin-left      : auto;
        margin-right     : auto;
        border-radius    : 8px;
        filter           : drop-shadow(0 10px 8px rgb(0 0 0 / 0.04)) drop-shadow(0 4px 3px rgb(0 0 0 / 0.1));
        padding          : 20px;
        background-color : white;
        width            : 88%;
        height           : fit-content;
        color            : #475569;
        font-size        : 16px;
    }

    .tableview_container .add_button {
        padding          : 8px 20px;
        font-size        : 14pt;
        font-weight      : bold;
        display          : inline-flex;
        flex-direction   : row;
        align-items      : center;
        align-content    : center;
        justify-content  : center;
        border           : none;
        background-color : #6366F1;
        border-radius    : 8px;
        color            : white;
        cursor           : pointer;
        gap              : 8px;
    }

    .tableview_container .add_button:hover {
        background-color : #7E80F1;
    }
    
    .label_rent {
        background-color: #1080e8 !important;
        color: #FFF !important;
        border: none !important;
    }
    .label_sale {
        background-color: #f97316 !important;
        color: #FFF !important;
        border: none !important;
    }
</style>


<main id="app"></main><script>document.getElementById('app').innerHTML=''</script><!---->


<style>/* fakecss:./guest/property.esbuild-svelte-fake-css */
.property_container.svelte-116cph6.svelte-116cph6.svelte-116cph6 {
  width: 70%;
  margin: 70px auto 50px auto;
}
.property.svelte-116cph6.svelte-116cph6.svelte-116cph6 {
  height: fit-content;
  background-color: #F0F0F0;
  border-radius: 8px;
  padding: 15px 15px 70px 15px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  position: relative;
}
.property_main.svelte-116cph6.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  align-content: flex-start;
  justify-content: flex-start;
  align-items: flex-start;
  gap: 15px;
}
.property_main.svelte-116cph6 .property_images.svelte-116cph6.svelte-116cph6 {
  width: 260px;
  height: 160px;
  flex: none;
  overflow: hidden;
  border-radius: 8px;
}
.property_main.svelte-116cph6 .property_images img.svelte-116cph6.svelte-116cph6 {
  object-fit: cover;
  width: 100%;
  height: 100%;
}
.property_main.svelte-116cph6 .property_images .image_empty.svelte-116cph6.svelte-116cph6 {
  border-radius: 8px;
  object-fit: cover;
  width: 100%;
  height: 100%;
  background-color: rgb(0 0 0 / 0.06);
  display: flex;
  justify-content: center;
  align-items: center;
}
.property_main.svelte-116cph6 .property_info.svelte-116cph6.svelte-116cph6 {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.property_main.svelte-116cph6 .property_info .col1.svelte-116cph6.svelte-116cph6 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-direction: row;
}
.property_main.svelte-116cph6 .property_info .col1 .left.svelte-116cph6.svelte-116cph6 {
  display: flex;
  gap: 15px;
  align-items: center;
}
.property_main.svelte-116cph6 .property_info .col1 .left .purpose.svelte-116cph6.svelte-116cph6,
.property_main.svelte-116cph6 .property_info .col1 .left .house_type.svelte-116cph6.svelte-116cph6,
.property_main.svelte-116cph6 .property_info .col1 .edit_property.svelte-116cph6.svelte-116cph6 {
  background-color: #F97316;
  padding: 7px 18px;
  border-radius: 8px;
  color: white;
  font-size: 14px;
  text-transform: capitalize;
  text-decoration: none;
}
.property_main.svelte-116cph6 .property_info .col1 .left .house_type.svelte-116cph6.svelte-116cph6,
.property_main.svelte-116cph6 .property_info .col1 .edit_property.svelte-116cph6.svelte-116cph6 {
  display: flex;
  gap: 10px;
  align-items: center;
}
.property_main.svelte-116cph6 .property_info .col1 .edit_property.svelte-116cph6.svelte-116cph6:hover {
  background-color: #F58433;
}
.property_main.svelte-116cph6 .property_info .col2.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.property_main.svelte-116cph6 .property_info .col2 h1.svelte-116cph6.svelte-116cph6 {
  margin: 0;
  font-size: 32px;
}
.property_main.svelte-116cph6 .property_info .col2 p.svelte-116cph6.svelte-116cph6 {
  margin: 0 0 10px 0;
}
.property_main.svelte-116cph6 .property_info .col2 .address.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
}
.property_secondary.svelte-116cph6.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.property_secondary.svelte-116cph6 .feature_number.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-evenly;
  width: 100%;
}
.property_secondary.svelte-116cph6 .feature_number .feature_item.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  text-transform: capitalize;
}
.property_secondary.svelte-116cph6 p.svelte-116cph6.svelte-116cph6 {
  margin: 0;
}
.property_secondary.svelte-116cph6 b.svelte-116cph6.svelte-116cph6 {
  font-size: 22px;
}
.property_floors.svelte-116cph6.svelte-116cph6.svelte-116cph6 {
  width: 70%;
  margin: 0 auto;
}
.property_floors.svelte-116cph6 h3.svelte-116cph6.svelte-116cph6 {
  font-size: 22px;
  margin: 0 0 15px 0;
  text-align: center;
}
.property_floors.svelte-116cph6 .floor_lists.svelte-116cph6.svelte-116cph6 {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item.svelte-116cph6.svelte-116cph6 {
  display: flex;
  align-items: flex-start;
  gap: 35px;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .left.svelte-116cph6.svelte-116cph6 {
  flex-grow: 1;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .left h5.svelte-116cph6.svelte-116cph6 {
  font-size: 22px;
  text-transform: capitalize;
  font-weight: normal;
  margin: 0 0 15px 0;
  width: 100%;
}
.property_floors.svelte-116cph6 .floor_lists .floor_lists .floor_item .left.svelte-116cph6 .room_lists.svelte-116cph6 {
  font-size: 14px;
  width: 100%;
  color: #475569;
  border: 1px solid #CBD5E1;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .left.svelte-116cph6 .room_lists .room_item.svelte-116cph6 {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  text-transform: capitalize;
  border-bottom: 1px solid #CBD5E1;
  padding: 5px 0;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .floor_plan_image.svelte-116cph6.svelte-116cph6 {
  width: 240px;
  height: 140px;
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #CBD5E1;
  margin-top: 45px;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .floor_plan_image img.svelte-116cph6.svelte-116cph6 {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .floor_plan_image span.svelte-116cph6.svelte-116cph6 {
  border-radius: 8px;
  object-fit: cover;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 8px;
  justify-content: center;
  align-items: center;
}
.property_floors.svelte-116cph6 .floor_lists .floor_item .floor_plan_image span p.svelte-116cph6.svelte-116cph6 {
  margin: 0;
}
.property_less_more.svelte-116cph6.svelte-116cph6.svelte-116cph6 {
  height: 50px;
  background: linear-gradient(to top, #F0F0F0, #F0F0F0, #F0F0F0, transparent);
  bottom: 0;
  position: absolute;
  z-index: 90;
  width: -webkit-fill-available;
  display: flex;
  justify-content: center;
}
</style>
<script>(() => {
  // node_modules/svelte/src/runtime/internal/utils.js
  function noop() {
  }
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return (
      /** @type {T & S} */
      tar
    );
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url) {
    if (element_src === url)
      return true;
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function subscribe(store, ...callbacks) {
    if (store == null) {
      for (const callback of callbacks) {
        callback(void 0);
      }
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function component_subscribe(component, store, callback) {
    component.$.on_destroy.push(subscribe(store, callback));
  }
  function null_to_empty(value) {
    return value == null ? "" : value;
  }

  // node_modules/svelte/src/runtime/internal/globals.js
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton = class {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element2, listener) {
      this._listeners.set(element2, listener);
      this._getObserver().observe(element2, this.options);
      return () => {
        this._listeners.delete(element2);
        this._observer.unobserve(element2);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          ResizeObserverSingleton.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

  // node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function comment(content) {
    return document.createComment(content);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
      attr(node, key, attributes[key]);
    }
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.data === data)
      return;
    text2.data = /** @type {string} */
    data;
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$.on_mount.push(fn);
  }

  // node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = /* @__PURE__ */ Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$);
        }
      } catch (e) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($) {
    if ($.fragment !== null) {
      $.update();
      run_all($.before_update);
      const dirty = $.dirty;
      $.dirty = [-1];
      $.fragment && $.fragment.p($.ctx, dirty);
      $.after_update.forEach(add_render_callback);
    }
  }
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
  }

  // node_modules/svelte/src/runtime/internal/transitions.js
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  // node_modules/svelte/src/runtime/internal/each.js
  function ensure_array_like(array_like_or_iterator) {
    return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }

  // node_modules/svelte/src/runtime/internal/spread.js
  function get_spread_update(levels, updates) {
    const update2 = {};
    const to_null_out = {};
    const accounted_for = { $scope: 1 };
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update2[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update2))
        update2[key] = void 0;
    }
    return update2;
  }

  // node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

  // node_modules/svelte/src/runtime/internal/Component.js
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor) {
    const { fragment, after_update } = component.$;
    fragment && fragment.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$.on_mount.map(run).filter(is_function);
      if (component.$.on_destroy) {
        component.$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $ = component.$;
    if ($.fragment !== null) {
      flush_render_callbacks($.after_update);
      run_all($.on_destroy);
      $.fragment && $.fragment.d(detaching);
      $.on_destroy = $.fragment = null;
      $.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$.dirty.fill(0);
    }
    component.$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance3, create_fragment3, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $ = component.$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$.root
    };
    append_styles && append_styles($.root);
    let ready = false;
    $.ctx = instance3 ? instance3(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($.ctx && not_equal($.ctx[i], $.ctx[i] = value)) {
        if (!$.skip_bound && $.bound[i])
          $.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $.update();
    ready = true;
    run_all($.before_update);
    $.fragment = create_fragment3 ? create_fragment3($.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $.fragment && $.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $.fragment && $.fragment.c();
      }
      if (options.intro)
        transition_in(component.$.fragment);
      mount_component(component, options.target, options.anchor);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $ctor;
      /** Slots */
      $s;
      /** The Svelte component instance */
      $c;
      /** Whether or not the custom element is connected */
      $cn = false;
      /** Component props data */
      $d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $l_u = /* @__PURE__ */ new Map();
      constructor($componentCtor, $slots, use_shadow_dom) {
        super();
        this.$ctor = $componentCtor;
        this.$s = $slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$l[type] = this.$l[type] || [];
        this.$l[type].push(listener);
        if (this.$c) {
          const unsub = this.$c.$on(type, listener);
          this.$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$c) {
          const unsub = this.$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$cn = true;
        if (!this.$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$cn) {
            return;
          }
          const $slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$s) {
            if (name in existing_slots) {
              $slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$g_p(attribute.name);
            if (!(name in this.$d)) {
              this.$d[name] = get_custom_element_value(name, attribute.value, this.$p_d, "toProp");
            }
          }
          this.$c = new this.$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$d,
              $slots,
              $scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$r = true;
            for (const key in this.$p_d) {
              this.$d[key] = this.$c.$.ctx[this.$c.$.props[key]];
              if (this.$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$d[key],
                  this.$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(key);
                } else {
                  this.setAttribute(this.$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$r = false;
          };
          this.$c.$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$l) {
            for (const listener of this.$l[type]) {
              const unsub = this.$c.$on(type, listener);
              this.$l_u.set(listener, unsub);
            }
          }
          this.$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$r)
          return;
        attr2 = this.$g_p(attr2);
        this.$d[attr2] = get_custom_element_value(attr2, newValue, this.$p_d, "toProp");
        this.$c?.$set({ [attr2]: this.$d[attr2] });
      }
      disconnectedCallback() {
        this.$cn = false;
        Promise.resolve().then(() => {
          if (!this.$cn) {
            this.$c.$destroy();
            this.$c = void 0;
          }
        });
      }
      $g_p(attribute_name) {
        return Object.keys(this.$p_d).find(
          (key) => this.$p_d[key].attribute === attribute_name || !this.$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop, value, props_definition, transform) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform || !props_definition[prop]) {
      return value;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$.callbacks[type] || (this.$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$set && !is_empty(props)) {
        this.$.skip_bound = true;
        this.$set(props);
        this.$.skip_bound = false;
      }
    }
  };

  // node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION = "4";

  // node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

  // node_modules/svelte/src/runtime/store/index.js
  var subscriber_queue = [];
  function writable(value, start = noop) {
    let stop;
    const subscribers = /* @__PURE__ */ new Set();
    function set(new_value) {
      if (safe_not_equal(value, new_value)) {
        value = new_value;
        if (stop) {
          const run_queue = !subscriber_queue.length;
          for (const subscriber of subscribers) {
            subscriber[1]();
            subscriber_queue.push(subscriber, value);
          }
          if (run_queue) {
            for (let i = 0; i < subscriber_queue.length; i += 2) {
              subscriber_queue[i][0](subscriber_queue[i + 1]);
            }
            subscriber_queue.length = 0;
          }
        }
      }
    }
    function update2(fn) {
      set(fn(value));
    }
    function subscribe2(run2, invalidate = noop) {
      const subscriber = [run2, invalidate];
      subscribers.add(subscriber);
      if (subscribers.size === 1) {
        stop = start(set, update2) || noop;
      }
      run2(value);
      return () => {
        subscribers.delete(subscriber);
        if (subscribers.size === 0 && stop) {
          stop();
          stop = null;
        }
      };
    }
    return { set, update: update2, subscribe: subscribe2 };
  }

  // translation.json
  var translation_default = {
    about: "About",
    aboutTW: "\u6982\u8981",
    agencyFee: "Agency Fee:",
    agencyFeeTW: "\u4EF2\u4ECB\u8CBB:",
    all: "All",
    allTW: "\u5168\u90E8",
    arStreetView: "AR Street view",
    arStreetViewTW: "\u8857\u666F\u627E\u623F",
    aroundHome: "Around Home",
    aroundHomeTW: "\u5468\u908A\u8CC7\u8A0A",
    askByText: "Ask by Text",
    askByTextTW: "\u50B3\u7C21\u8A0A",
    basement: "Basement",
    basementTW: "\u5730\u4E0B\u5BA4",
    bath: "bath",
    bathTW: "\u885B",
    bathroomN: "Bathroom #",
    bathroomNTW: "\u885B\u6D74 ",
    bed: "bed",
    bedTW: "\u623F",
    bedroomN: "Bedroom #",
    bedroomNTW: "\u81E5\u5BA4 ",
    buildingMaterial: "Building Material",
    buildingMaterialTW: "\u5EFA\u7BC9\u6750\u6599",
    callMe: "Call Me",
    callMeTW: "\u96FB\u8A71\u806F\u7D61",
    clickVerificationLink: "Please click the link in that email.",
    clickVerificationLinkTW: "\u8ACB\u81F3\u60A8\u7684\u8A3B\u518AEmail \u4E26\u9EDE\u9078\u9023\u7D50\u4F86\u9A57\u8B49\u4FE1\u7BB1\u3002",
    confirm: "Confirm",
    confirmTW: "\u518D\u6B21\u78BA\u8A8D\u5BC6\u78BC",
    constructionDate: "Construction Date",
    constructionDateTW: "\u5EFA\u6210\u6642\u9593",
    disclaimer1: "Disclaimer: The information provided on this platform is for reference purposes only. We do not guarantee the accuracy or completeness of the information presented. The actual information regarding the property is provided by the seller and should be verified independently. We do not assume any responsibility for any errors or omissions in the information provided. Please be aware of potential scams or frauds. We strongly advise you to conduct your own due diligence and exercise caution when communicating with anyone you meet online. Do not send money or personal information until you have verified the authenticity of the individual or company you are dealing with.",
    disclaimer1TW: "\u514D\u8CAC\u8072\u660E\uFF1A \u672C\u5E73\u53F0\u63D0\u4F9B\u7684\u8CC7\u8A0A\u50C5\u4F9B\u53C3\u8003\u4E4B\u7528\u3002\u6211\u5011\u4E0D\u4FDD\u8B49\u6240\u63D0\u4F9B\u7684\u8CC7\u8A0A\u7684\u6E96\u78BA\u6027\u6216\u5B8C\u6574\u6027\u3002\u6709\u95DC\u7269\u4EF6\u7684\u5BE6\u969B\u8CC7\u8A0A\u7531\u8CE3\u65B9\u63D0\u4F9B\uFF0C\u61C9\u7368\u7ACB\u9032\u884C\u9A57\u8B49\u3002\u6211\u5011\u4E0D\u627F\u64D4\u4EFB\u4F55\u56E0\u6240\u63D0\u4F9B\u8CC7\u8A0A\u4E2D\u7684\u932F\u8AA4\u6216\u907A\u6F0F\u800C\u5F15\u8D77\u7684\u8CAC\u4EFB\u3002 \u8ACB\u6CE8\u610F\u53EF\u80FD\u5B58\u5728\u7684\u8A50\u9A19\u6216\u6B3A\u8A50\u884C\u70BA\u3002\u6211\u5011\u5F37\u70C8\u5EFA\u8B70\u60A8\u81EA\u884C\u9032\u884C\u5145\u5206\u7684\u5BE9\u614E\u8A55\u4F30\uFF0C\u4E26\u5728\u8207\u60A8\u5728\u7DDA\u4E0A\u9047\u5230\u7684\u4EFB\u4F55\u4EBA\u6E9D\u901A\u6642\u8B39\u614E\u884C\u4E8B\u3002\u5728\u9A57\u8B49\u60A8\u6240\u806F\u7D61\u7684\u500B\u4EBA\u6216\u516C\u53F8\u7684\u771F\u5BE6\u6027\u4E4B\u524D\uFF0C\u8ACB\u52FF\u767C\u9001\u91D1\u9322\u6216\u500B\u4EBA\u8CC7\u8A0A\u3002",
    email: "Email",
    emailTW: "\u4FE1\u7BB1",
    facility: "Facility",
    facilityTW: "\u8A2D\u65BD",
    feet: "feet",
    feetTW: "\u82F1\u5C3A",
    floor: "Floor",
    floorN: "Floor #",
    floorNTW: "\u6A13\u5C64 ",
    floorTW: "\u6A13\u5C64",
    floors: "Floors",
    floorsTW: "\u6A13\u5C64",
    forRent: "For Rent",
    forRentTW: "\u51FA\u79DF",
    forgotPassword: "Forgot Password",
    forgotPasswordTW: "\u5FD8\u8A18\u5BC6\u78BC",
    haveAccount: "Have an Account ",
    haveAccountTW: "\u5DF2\u662F\u6703\u54E1\uFF1F",
    hospital: "Hospital",
    hospitalTW: "\u91AB\u9662",
    information: "Information",
    informationTW: "\u8CC7\u8A0A",
    key: "EN",
    keyTW: "TW",
    lastPrice: "Last Price",
    lastPriceTW: "\u6700\u8FD1\u50F9\u683C",
    likedProperty: "Liked Property",
    likedPropertyTW: "\u559C\u6B61\u7684\u7269\u4EF6",
    lookDown: "Look Down",
    lookDownTW: "\u5F80\u4E0B\u770B",
    lookLeft: "Look Left",
    lookLeftTW: "\u5F80\u5DE6\u770B",
    lookRight: "Look Right",
    lookRightTW: "\u5F80\u53F3\u770B",
    lookTop: "Look Top",
    lookTopTW: "\u5F80\u4E0A\u770B",
    m: "m",
    m2: "m2",
    m2TW: "\u5E73\u65B9\u7C73",
    mTW: "\u516C\u5C3A",
    miles: "miles",
    milesTW: "\u82F1\u91CC",
    moveCamera: "Slowly move the Camera to Look Around ",
    moveCameraTW: "\u5DE6\u53F3\u79FB\u52D5\u627E\u7269\u4EF6",
    onSale: "On Sale",
    onSaleTW: "\u62CD\u8CE3\u4E2D",
    openMap: "Open Map",
    openMapTW: "\u67E5\u770B\u4F4D\u7F6E",
    password: "Password",
    passwordTW: "\u5BC6\u78BC",
    ping: "ping",
    pingTW: "\u576A",
    pleaseVerify: "Please Verify Your Email",
    pleaseVerifyTW: "\u9A57\u8B49Email",
    priceHistory: "Price History",
    priceHistoryTW: "\u6B77\u53F2\u50F9\u683C",
    publish: "Publish",
    publishTW: "\u520A\u767B",
    resendVerificationLink: "Resend Verification Link",
    resendVerificationLinkTW: "\u91CD\u5BC4 \u9A57\u8B49\u9023\u7D50",
    restaurant: "Restaurant",
    restaurantTW: "\u9910\u5EF3",
    scanning: "Scanning...",
    scanningTW: "\u6383\u63CF\u74B0\u5883\u4E2D...",
    school: "School",
    schoolTW: "\u5B78\u6821",
    seeMore: "See More...",
    seeMoreTW: "\u67E5\u770B\u66F4\u591A...",
    signIn: "Sign In",
    signInTW: "\u767B\u5165",
    signOut: "Sign Out ",
    signOutTW: "\u767B\u51FA",
    signUp: "Sign Up",
    signUpEmail: "Sign up with Email ",
    signUpEmailTW: "\u4FE1\u7BB1\u8A3B\u518A",
    signUpTW: "\u8A3B\u518A",
    size: "Size",
    sizeTW: "\u5C3A\u5BF8",
    sqft: "sqft",
    sqftTW: "\u5E73\u65B9\u7C73",
    store: "Store",
    storeTW: "\u5546\u5E97",
    transit: "Transit",
    transitTW: "\u5927\u773E\u904B\u8F38",
    usdPerMonth: "$$/mo",
    usdPerMonthTW: "$$/\u6708",
    weSentEmail: "We've sent an email to your email account.",
    weSentEmailTW: "\u6211\u5011\u5DF2\u5BC4\u4FE1\u81F3\u60A8\u7684Email!",
    welcome: "Welcome to HapSTR ",
    welcomeTW: "\u6B61\u8FCE\u4F7F\u7528HapSTR"
  };

  // _components/uiState.js
  var isSideMenuOpen = writable(false);
  var original = translation_default;
  function translationStore() {
    let currentLang = "";
    if (window && window.localStorage) {
      currentLang = window.localStorage.getItem("lang") || "";
    }
    let kv = { currentLang };
    let switchLang = () => {
      if (currentLang === "EN" || currentLang === "") {
        for (let k in original) {
          kv[k] = original[k];
        }
      } else {
        for (let k in original) {
          if (original[k + currentLang])
            kv[k] = original[k + currentLang];
        }
      }
    };
    const { subscribe: subscribe2, set, update: update2 } = writable(kv);
    return {
      currentLang,
      subscribe: subscribe2,
      changeLanguage: (newV) => {
        if (window && window.localStorage) {
          window.localStorage.setItem("lang", newV);
        }
        currentLang = newV;
        kv.currentLang = newV;
        switchLang();
        console.log("kv", kv);
        if (Object.keys(kv).length === 0)
          return;
        update2((el) => kv);
      }
    };
  }
  var T = translationStore();

  // node_modules/.pnpm/svelte-icons-pack@2.1.0/node_modules/svelte-icons-pack/Icon.svelte
  function create_fragment(ctx) {
    let svg;
    let svg_levels = [
      { width: (
        /*size*/
        ctx[1]
      ) },
      { height: (
        /*size*/
        ctx[1]
      ) },
      { "stroke-width": "0" },
      { class: (
        /*className*/
        ctx[2]
      ) },
      /*src*/
      ctx[0].a,
      /*attr*/
      ctx[4],
      { xmlns: "http://www.w3.org/2000/svg" }
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        svg.innerHTML = /*innerHtml*/
        ctx[3];
      },
      p(ctx2, [dirty]) {
        if (dirty & /*innerHtml*/
        8)
          svg.innerHTML = /*innerHtml*/
          ctx2[3];
        ;
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          dirty & /*size*/
          2 && { width: (
            /*size*/
            ctx2[1]
          ) },
          dirty & /*size*/
          2 && { height: (
            /*size*/
            ctx2[1]
          ) },
          { "stroke-width": "0" },
          dirty & /*className*/
          4 && { class: (
            /*className*/
            ctx2[2]
          ) },
          dirty & /*src*/
          1 && /*src*/
          ctx2[0].a,
          dirty & /*attr*/
          16 && /*attr*/
          ctx2[4],
          { xmlns: "http://www.w3.org/2000/svg" }
        ]));
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(svg);
        }
      }
    };
  }
  function instance($self, $props, $invalidate) {
    let { src } = $props;
    let { size = "1em" } = $props;
    let { color = void 0 } = $props;
    let { title = void 0 } = $props;
    let { className = "" } = $props;
    let innerHtml;
    let attr2;
    $self.$set = ($props2) => {
      if ("src" in $props2)
        $invalidate(0, src = $props2.src);
      if ("size" in $props2)
        $invalidate(1, size = $props2.size);
      if ("color" in $props2)
        $invalidate(5, color = $props2.color);
      if ("title" in $props2)
        $invalidate(6, title = $props2.title);
      if ("className" in $props2)
        $invalidate(2, className = $props2.className);
    };
    $self.$.update = () => {
      if ($self.$.dirty & /*color, src*/
      33) {
        $: {
          $invalidate(4, attr2 = {});
          if (color) {
            if (src.a.stroke !== "none") {
              $invalidate(4, attr2.stroke = color, attr2);
            }
            if (src.a.fill !== "none") {
              $invalidate(4, attr2.fill = color, attr2);
            }
          }
        }
      }
      if ($self.$.dirty & /*title, src*/
      65) {
        $: {
          $invalidate(3, innerHtml = (title ? `<title>${title}</title>` : "") + src.c);
        }
      }
    };
    return [src, size, className, innerHtml, attr2, color, title];
  }
  var Icon = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, {
        src: 0,
        size: 1,
        color: 5,
        title: 6,
        className: 2
      });
    }
  };
  var Icon_default = Icon;

  // node_modules/.pnpm/svelte-icons-pack@2.1.0/node_modules/svelte-icons-pack/fa/FaSolidHome.js
  var FaSolidHome_default = {
    a: {
      viewBox: "0 0 576 512"
    },
    c: '<path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path>'
  };

  // node_modules/.pnpm/svelte-icons-pack@2.1.0/node_modules/svelte-icons-pack/fa/FaSolidMapMarkerAlt.js
  var FaSolidMapMarkerAlt_default = {
    a: {
      viewBox: "0 0 384 512"
    },
    c: '<path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"></path>'
  };

  // guest/property.svelte
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[1] = list[i];
    return child_ctx;
  }
  function get_each_context_1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[4] = list[i];
    return child_ctx;
  }
  function create_else_block_2(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.innerHTML = `<i class="gg-image"></i>`;
        attr(div, "class", "image_empty svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_if_block_3(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = propItem.images[0]))
          attr(img, "src", img_src_value);
        attr(img, "alt", "");
        attr(img, "class", "svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  function create_else_block_1(ctx) {
    let div;
    return {
      c() {
        div = element("div");
        div.innerHTML = `<p class="svelte-116cph6">No Floors</p>`;
        attr(div, "class", "no_floors");
      },
      m(target, anchor) {
        insert(target, div, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_if_block(ctx) {
    let div;
    let each_value = ensure_array_like(propItem.floorList);
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "floor_lists svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem, $T*/
        1) {
          each_value = ensure_array_like(propItem.floorList);
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_if_block_2(ctx) {
    let div;
    let each_value_1 = ensure_array_like(
      /*floors*/
      ctx[1].rooms
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "room_lists svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        0) {
          each_value_1 = ensure_array_like(
            /*floors*/
            ctx2[1].rooms
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_1(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_1.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block_1(ctx) {
    let div;
    let span0;
    let t1;
    let span1;
    let t4;
    return {
      c() {
        div = element("div");
        span0 = element("span");
        span0.textContent = `${/*room*/
        ctx[4].name || "-"}`;
        t1 = space();
        span1 = element("span");
        span1.textContent = `${/*room*/
        ctx[4].sizeM2 || "-"} M2`;
        t4 = space();
        attr(span0, "class", "svelte-116cph6");
        attr(span1, "class", "svelte-116cph6");
        attr(div, "class", "room_item svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span0);
        append(div, t1);
        append(div, span1);
        append(div, t4);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_else_block(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*floors*/
        ctx[1].planImageUrl))
          attr(img, "src", img_src_value);
        attr(img, "alt", "");
        attr(img, "class", "svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  function create_if_block_1(ctx) {
    let span;
    return {
      c() {
        span = element("span");
        span.innerHTML = `<i class="gg-image"></i> <p class="svelte-116cph6">No Image</p>`;
        attr(span, "class", "svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, span, anchor);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  function create_each_block(ctx) {
    let div2;
    let div0;
    let h5;
    let t0_value = (
      /*floors*/
      (ctx[1].type === "basement" ? (
        /*$T*/
        ctx[0].basement
      ) : `${/*$T*/
      ctx[0].floorN}${/*floors*/
      ctx[1].floor}`) + ""
    );
    let t0;
    let t1;
    let c;
    let t2;
    let t3;
    let div1;
    let t4;
    let if_block0 = (
      /*floors*/
      ctx[1].rooms && create_if_block_2(ctx)
    );
    function select_block_type_2(ctx2, dirty) {
      if (
        /*floors*/
        ctx2[1].planImageUrl === ""
      )
        return create_if_block_1;
      return create_else_block;
    }
    let current_block_type = select_block_type_2(ctx, -1);
    let if_block1 = current_block_type(ctx);
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        h5 = element("h5");
        t0 = text(t0_value);
        t1 = space();
        c = comment(" TODO: currently room list only 1 object, fix Tarantool to accept array ");
        t2 = space();
        if (if_block0)
          if_block0.c();
        t3 = space();
        div1 = element("div");
        if_block1.c();
        t4 = space();
        attr(h5, "class", "svelte-116cph6");
        attr(div0, "class", "left svelte-116cph6");
        attr(div1, "class", "floor_plan_image svelte-116cph6");
        attr(div2, "class", "floor_item svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div0, h5);
        append(h5, t0);
        append(div0, t1);
        append(div0, c);
        append(div0, t2);
        if (if_block0)
          if_block0.m(div0, null);
        append(div2, t3);
        append(div2, div1);
        if_block1.m(div1, null);
        append(div2, t4);
      },
      p(ctx2, dirty) {
        if (dirty & /*$T*/
        1 && t0_value !== (t0_value = /*floors*/
        (ctx2[1].type === "basement" ? (
          /*$T*/
          ctx2[0].basement
        ) : `${/*$T*/
        ctx2[0].floorN}${/*floors*/
        ctx2[1].floor}`) + ""))
          set_data(t0, t0_value);
        if (
          /*floors*/
          ctx2[1].rooms
        )
          if_block0.p(ctx2, dirty);
        if_block1.p(ctx2, dirty);
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if (if_block0)
          if_block0.d();
        if_block1.d();
      }
    };
  }
  function create_fragment2(ctx) {
    let section;
    let div16;
    let div8;
    let div0;
    let t0;
    let div7;
    let div4;
    let div3;
    let div1;
    let t1_value = (propItem.purpose === "rent" ? (
      /*$T*/
      ctx[0].forRent
    ) : (
      /*$T*/
      ctx[0].onSale
    )) + "";
    let t1;
    let div1_class_value;
    let t2;
    let div2;
    let icon0;
    let t3;
    let span0;
    let t5;
    let div6;
    let h1;
    let t8;
    let p0;
    let t9_value = (
      /*$T*/
      ctx[0].agencyFee + ""
    );
    let t9;
    let t10;
    let t11_value = propItem.agencyFeePercent + "";
    let t11;
    let t12;
    let t13;
    let div5;
    let icon1;
    let t14;
    let span1;
    let t16;
    let div14;
    let div13;
    let div9;
    let b0;
    let t18;
    let p1;
    let t19_value = (
      /*$T*/
      ctx[0].floors + ""
    );
    let t19;
    let t20;
    let div10;
    let b1;
    let t22;
    let p2;
    let t23_value = (
      /*$T*/
      ctx[0].bath + ""
    );
    let t23;
    let t24;
    let div11;
    let b2;
    let t26;
    let p3;
    let t27_value = (
      /*$T*/
      ctx[0].bed + ""
    );
    let t27;
    let t28;
    let div12;
    let b3;
    let t29_value = (propItem.sizeM2 || "0") + "";
    let t29;
    let t30;
    let t31_value = (
      /*$T*/
      ctx[0].m + ""
    );
    let t31;
    let t32;
    let t33;
    let p4;
    let t35;
    let div15;
    let h3;
    let t36_value = (
      /*$T*/
      ctx[0].floors + ""
    );
    let t36;
    let t37;
    let current;
    function select_block_type(ctx2, dirty) {
      if (propItem.images && propItem.images.length)
        return create_if_block_3;
      return create_else_block_2;
    }
    let current_block_type = select_block_type(ctx, -1);
    let if_block0 = current_block_type(ctx);
    icon0 = new Icon_default({
      props: {
        color: "#FFFF",
        size: 16,
        src: FaSolidHome_default
      }
    });
    icon1 = new Icon_default({
      props: {
        color: "#f97316",
        size: 18,
        src: FaSolidMapMarkerAlt_default
      }
    });
    function select_block_type_1(ctx2, dirty) {
      if (propItem.floorList && propItem.floorList.length)
        return create_if_block;
      return create_else_block_1;
    }
    let current_block_type_1 = select_block_type_1(ctx, -1);
    let if_block1 = current_block_type_1(ctx);
    return {
      c() {
        section = element("section");
        div16 = element("div");
        div8 = element("div");
        div0 = element("div");
        if_block0.c();
        t0 = space();
        div7 = element("div");
        div4 = element("div");
        div3 = element("div");
        div1 = element("div");
        t1 = text(t1_value);
        t2 = space();
        div2 = element("div");
        create_component(icon0.$.fragment);
        t3 = space();
        span0 = element("span");
        span0.textContent = `${propItem.houseType}`;
        t5 = space();
        div6 = element("div");
        h1 = element("h1");
        h1.textContent = `$ ${propItem.lastPrice || "0.00"}`;
        t8 = space();
        p0 = element("p");
        t9 = text(t9_value);
        t10 = text(" : ");
        t11 = text(t11_value);
        t12 = text("%");
        t13 = space();
        div5 = element("div");
        create_component(icon1.$.fragment);
        t14 = space();
        span1 = element("span");
        span1.textContent = `${propItem.formattedAddress}`;
        t16 = space();
        div14 = element("div");
        div13 = element("div");
        div9 = element("div");
        b0 = element("b");
        b0.textContent = `${propItem.numberOfFloors || "0"}`;
        t18 = space();
        p1 = element("p");
        t19 = text(t19_value);
        t20 = space();
        div10 = element("div");
        b1 = element("b");
        b1.textContent = `${propItem.bathroom || "0"}`;
        t22 = space();
        p2 = element("p");
        t23 = text(t23_value);
        t24 = space();
        div11 = element("div");
        b2 = element("b");
        b2.textContent = `${propItem.bedroom || "0"}`;
        t26 = space();
        p3 = element("p");
        t27 = text(t27_value);
        t28 = space();
        div12 = element("div");
        b3 = element("b");
        t29 = text(t29_value);
        t30 = space();
        t31 = text(t31_value);
        t32 = text("2");
        t33 = space();
        p4 = element("p");
        p4.textContent = "Size";
        t35 = space();
        div15 = element("div");
        h3 = element("h3");
        t36 = text(t36_value);
        t37 = space();
        if_block1.c();
        attr(div0, "class", "property_images svelte-116cph6");
        attr(div1, "class", div1_class_value = null_to_empty(propItem.purpose === "rent" ? `purpose label_rent` : `purpose label_sale`) + " svelte-116cph6");
        attr(div2, "class", "house_type svelte-116cph6");
        attr(div3, "class", "left svelte-116cph6");
        attr(div4, "class", "col1 svelte-116cph6");
        attr(h1, "class", "svelte-116cph6");
        attr(p0, "class", "svelte-116cph6");
        attr(div5, "class", "address svelte-116cph6");
        attr(div6, "class", "col2 svelte-116cph6");
        attr(div7, "class", "property_info svelte-116cph6");
        attr(div8, "class", "property_main svelte-116cph6");
        attr(b0, "class", "svelte-116cph6");
        attr(p1, "class", "svelte-116cph6");
        attr(div9, "class", "feature_item svelte-116cph6");
        attr(b1, "class", "svelte-116cph6");
        attr(p2, "class", "svelte-116cph6");
        attr(div10, "class", "feature_item svelte-116cph6");
        attr(b2, "class", "svelte-116cph6");
        attr(p3, "class", "svelte-116cph6");
        attr(div11, "class", "feature_item svelte-116cph6");
        attr(b3, "class", "svelte-116cph6");
        attr(p4, "class", "svelte-116cph6");
        attr(div12, "class", "feature_item svelte-116cph6");
        attr(div13, "class", "feature_number svelte-116cph6");
        attr(div14, "class", "property_secondary svelte-116cph6");
        attr(h3, "class", "svelte-116cph6");
        attr(div15, "class", "property_floors svelte-116cph6");
        attr(div16, "class", "property svelte-116cph6");
        attr(section, "class", "property_container svelte-116cph6");
      },
      m(target, anchor) {
        insert(target, section, anchor);
        append(section, div16);
        append(div16, div8);
        append(div8, div0);
        if_block0.m(div0, null);
        append(div8, t0);
        append(div8, div7);
        append(div7, div4);
        append(div4, div3);
        append(div3, div1);
        append(div1, t1);
        append(div3, t2);
        append(div3, div2);
        mount_component(icon0, div2, null);
        append(div2, t3);
        append(div2, span0);
        append(div7, t5);
        append(div7, div6);
        append(div6, h1);
        append(div6, t8);
        append(div6, p0);
        append(p0, t9);
        append(p0, t10);
        append(p0, t11);
        append(p0, t12);
        append(div6, t13);
        append(div6, div5);
        mount_component(icon1, div5, null);
        append(div5, t14);
        append(div5, span1);
        append(div16, t16);
        append(div16, div14);
        append(div14, div13);
        append(div13, div9);
        append(div9, b0);
        append(div9, t18);
        append(div9, p1);
        append(p1, t19);
        append(div13, t20);
        append(div13, div10);
        append(div10, b1);
        append(div10, t22);
        append(div10, p2);
        append(p2, t23);
        append(div13, t24);
        append(div13, div11);
        append(div11, b2);
        append(div11, t26);
        append(div11, p3);
        append(p3, t27);
        append(div13, t28);
        append(div13, div12);
        append(div12, b3);
        append(b3, t29);
        append(b3, t30);
        append(b3, t31);
        append(b3, t32);
        append(div12, t33);
        append(div12, p4);
        append(div16, t35);
        append(div16, div15);
        append(div15, h3);
        append(h3, t36);
        append(div15, t37);
        if_block1.m(div15, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if_block0.p(ctx2, dirty);
        if ((!current || dirty & /*$T*/
        1) && t1_value !== (t1_value = (propItem.purpose === "rent" ? (
          /*$T*/
          ctx2[0].forRent
        ) : (
          /*$T*/
          ctx2[0].onSale
        )) + ""))
          set_data(t1, t1_value);
        if ((!current || dirty & /*$T*/
        1) && t9_value !== (t9_value = /*$T*/
        ctx2[0].agencyFee + ""))
          set_data(t9, t9_value);
        if ((!current || dirty & /*$T*/
        1) && t19_value !== (t19_value = /*$T*/
        ctx2[0].floors + ""))
          set_data(t19, t19_value);
        if ((!current || dirty & /*$T*/
        1) && t23_value !== (t23_value = /*$T*/
        ctx2[0].bath + ""))
          set_data(t23, t23_value);
        if ((!current || dirty & /*$T*/
        1) && t27_value !== (t27_value = /*$T*/
        ctx2[0].bed + ""))
          set_data(t27, t27_value);
        if ((!current || dirty & /*$T*/
        1) && t31_value !== (t31_value = /*$T*/
        ctx2[0].m + ""))
          set_data(t31, t31_value);
        if ((!current || dirty & /*$T*/
        1) && t36_value !== (t36_value = /*$T*/
        ctx2[0].floors + ""))
          set_data(t36, t36_value);
        if_block1.p(ctx2, dirty);
      },
      i(local) {
        if (current)
          return;
        transition_in(icon0.$.fragment, local);
        transition_in(icon1.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(icon0.$.fragment, local);
        transition_out(icon1.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(section);
        }
        if_block0.d();
        destroy_component(icon0);
        destroy_component(icon1);
        if_block1.d();
      }
    };
  }
  var propItem = {/* propItem */};
  function instance2($self, $props, $invalidate) {
    let $T;
    component_subscribe($self, T, ($value) => $invalidate(0, $T = $value));
    onMount(() => {
      console.log(`Property Item = ${propItem}`);
    });
    return [$T];
  }
  var Property = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, {});
    }
  };
  var property_default = Property;

  // guest/property.svelte.ts
  var app = new property_default({ target: document.getElementById("app") });
})();
</script>
</body></html>