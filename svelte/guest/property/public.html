<html><head>
	<title>/*! title */</title>
	<meta content="#{ogURL}" property="og:url">
	<meta content="HapSTR" property="og:site_name">
	<meta content="#{title}" property="og:title">
	<meta content="#{ogDescription}" property="og:description">
	<meta content="tw_TW" property="og:locale">
	<meta content="en_EN" property="og:locale:alternate">
	<meta content="website" property="og:type">
	<meta content="#{ogImgURL}" property="og:image">
	<meta content="#{ogImgURL}" property="og:image:secure_url">
	<meta content="1200" property="og:image:width">
	<meta content="630" property="og:image:height">
	<meta content="Property Image" property="og:image:alt">
	<meta content="#{ogCreatedAt}" property="article:published_time">
	<meta content="#{ogUpdatedAt}" property="article:modified_time">
	<meta content="#{ogUpdatedAt}" property="article:updated_time">
	<meta content="summary" name="twitter:card">
	<meta content="I found an awesome property" name="twitter:title">
	<meta content="#{ogDescription}" name="twitter:description">
	<meta content="#{ogImgURL}" name="twitter:image">
	<!--	<meta name="twitter:site" content="@xd"/>-->
	<!--	<meta name="twitter:creator" content="@xd"/>-->
</head>
<body>
<style>
    *,
    *::before,
    *::after {
        box-sizing : border-box;
    }

    :root {
        -moz-tab-size : 4;
        -o-tab-size   : 4;
        tab-size      : 4;
    }

    html {
        max-width                : 100%;
        margin                   : auto;
        line-height-step         : 1.15;
        -webkit-text-size-adjust : 100%;
        font-size                : 13px;
    }

    body {
        font-family : Roboto, Helvetica, Arial, sans-serif;
        margin      : 0;
    }

    hr {
        height           : 0;
        border-top-width : 1px;
        width            : 100%;
        overflow         : hidden;
        color            : inherit;
        margin           : 0;
    }


    .label_rent {
        background-color : #1080E8 !important;
        color            : #FFF !important;
        border           : none !important;
    }

    .label_sale {
        background-color : #F97316 !important;
        color            : #FFF !important;
        border           : none !important;
    }
</style>


<main id="app"></main><script>document.getElementById('app').innerHTML=''</script><!---->


<style>/* fakecss:./_components/Growl.esbuild-svelte-fake-css */
.growl.hidden.svelte-1nas9kk.svelte-1nas9kk {
  display: none;
}
.growl.svelte-1nas9kk.svelte-1nas9kk {
  position: fixed;
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  bottom: 20px;
  right: 20px;
  padding: 10px 20px;
  border-radius: 3px;
  box-shadow: 0px 4px 24px 0px rgba(0, 0, 0, 0.25);
  z-index: 9999;
  min-width: 120px;
  max-width: 350px;
  height: fit-content;
}
.icon_growl {
  flex-shrink: 0;
}
.growl.svelte-1nas9kk span.svelte-1nas9kk {
  flex-shrink: 1;
}
.growl.info.svelte-1nas9kk.svelte-1nas9kk {
  background-color: #1080E8;
  color: #FFF;
}
.growl.success.svelte-1nas9kk.svelte-1nas9kk {
  background-color: #059669;
  color: #FFF;
}
.growl.error.svelte-1nas9kk.svelte-1nas9kk {
  background-color: #EF4444;
  color: #FFF;
}
.growl.warning.svelte-1nas9kk.svelte-1nas9kk {
  background-color: #D97706;
  color: #FFF;
}

/* fakecss:./_components/PillBox.esbuild-svelte-fake-css */
.pill-box.svelte-1x7s25u.svelte-1x7s25u {
  line-height: 25px;
  display: inline-flex;
}
.pill-box-left.svelte-1x7s25u.svelte-1x7s25u,
.pill-box-right.svelte-1x7s25u.svelte-1x7s25u {
  border: 1px solid #E6E6E6;
  border-radius: 4px;
  color: #666;
  padding: 2px;
  margin-bottom: 1em;
}
.pill-box-left.svelte-1x7s25u.svelte-1x7s25u {
  background-color: #E6E6E6;
  border-bottom-right-radius: 0;
  border-top-right-radius: 0;
  padding-left: 6px;
  text-align: center;
}
.pill-box-right.svelte-1x7s25u.svelte-1x7s25u {
  background-color: #FFF;
  border-bottom-left-radius: 0;
  border-top-left-radius: 0;
  border-left: 0;
  padding-left: 4px;
  padding-right: 6px;
  margin-right: 1em;
}
.pill-blue.svelte-1x7s25u .pill-box-left.svelte-1x7s25u,
.pill-blue.svelte-1x7s25u .pill-box-right.svelte-1x7s25u {
  border-color: #4DA6FF;
}
.pill-blue.svelte-1x7s25u .pill-box-left.svelte-1x7s25u {
  background-color: #4DA6FF;
  color: #E5F2FF;
}

/* fakecss:./_components/Property.esbuild-svelte-fake-css */
.property.svelte-13fvm7d.svelte-13fvm7d.svelte-13fvm7d {
  height: fit-content;
  background-color: #F0F0F0;
  border-radius: 8px;
  padding: 15px 15px 70px 15px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  position: relative;
}
.property.svelte-13fvm7d h3.svelte-13fvm7d.svelte-13fvm7d {
  font-size: 22px;
  margin: 0 0 15px 0;
  text-align: center;
}
.property_main.svelte-13fvm7d.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  align-content: flex-start;
  justify-content: flex-start;
  align-items: flex-start;
  gap: 20px;
}
.property_main.svelte-13fvm7d .property_images.svelte-13fvm7d.svelte-13fvm7d {
  width: 340px;
  height: 190px;
  flex: none;
  overflow: hidden;
  border-radius: 8px;
}
.property_main.svelte-13fvm7d .property_images img.svelte-13fvm7d.svelte-13fvm7d {
  object-fit: cover;
  width: 100%;
  height: 100%;
}
.property_main.svelte-13fvm7d .property_images .image_empty.svelte-13fvm7d.svelte-13fvm7d {
  border-radius: 8px;
  object-fit: cover;
  width: 100%;
  height: 100%;
  background-color: rgb(0 0 0 / 0.06);
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-size: 18px;
  justify-content: center;
  align-items: center;
}
.property_main.svelte-13fvm7d .property_info.svelte-13fvm7d.svelte-13fvm7d {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 20px;
}
.property_main.svelte-13fvm7d .property_info .col1.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-direction: row;
}
.property_main.svelte-13fvm7d .property_info .col1 .left.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  gap: 15px;
  align-items: center;
}
.property_main.svelte-13fvm7d .property_info .col1 .prop_status.svelte-13fvm7d.svelte-13fvm7d {
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 15px;
}
.property_main.svelte-13fvm7d .property_info .col1 .approved.svelte-13fvm7d.svelte-13fvm7d {
  background-color: rgba(140, 216, 107, 1);
  color: #FFFFFF;
}
.property_main.svelte-13fvm7d .property_info .col1 .pending.svelte-13fvm7d.svelte-13fvm7d {
  background-color: rgba(255, 208, 118, 1);
  color: #475569;
}
.property_main.svelte-13fvm7d .property_info .col1 .approved.svelte-13fvm7d.svelte-13fvm7d {
  background-color: rgba(140, 216, 107, 1);
  color: #FFFFFF;
}
.property_main.svelte-13fvm7d .property_info .col1 .left .purpose.svelte-13fvm7d.svelte-13fvm7d,
.property_main.svelte-13fvm7d .property_info .col1 .left .house_type.svelte-13fvm7d.svelte-13fvm7d,
.property_main.svelte-13fvm7d .property_info .col1 .edit_property.svelte-13fvm7d.svelte-13fvm7d {
  background-color: #F97316;
  padding: 7px 18px;
  border-radius: 8px;
  color: white;
  font-size: 14px;
  text-transform: capitalize;
  text-decoration: none;
}
.property_main.svelte-13fvm7d .property_info .col1 .left .house_type.svelte-13fvm7d.svelte-13fvm7d,
.property_main.svelte-13fvm7d .property_info .col1 .edit_property.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  gap: 10px;
  align-items: center;
}
.property_main.svelte-13fvm7d .property_info .col1 .edit_property.svelte-13fvm7d.svelte-13fvm7d:hover {
  background-color: #F58433;
}
.property_main.svelte-13fvm7d .property_info .col2.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.property_main.svelte-13fvm7d .property_info .col2 h1.svelte-13fvm7d.svelte-13fvm7d {
  margin: 0;
  font-size: 32px;
}
.property_main.svelte-13fvm7d .property_info .col2 p.svelte-13fvm7d.svelte-13fvm7d {
  margin: 0 0 10px 0;
}
.property_main.svelte-13fvm7d .property_info .col2 .address.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
}
.icon_address {
  flex-shrink: 0;
}
.property_main.svelte-13fvm7d .property_info .col2 .address span.svelte-13fvm7d.svelte-13fvm7d {
  flex-shrink: 1;
}
.property_secondary.svelte-13fvm7d.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: column;
  gap: 15px;
}
.property_secondary.svelte-13fvm7d .feature_number.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-evenly;
  width: 100%;
}
.property_secondary.svelte-13fvm7d .feature_number .feature_item.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  text-transform: capitalize;
}
.property_secondary.svelte-13fvm7d p.svelte-13fvm7d.svelte-13fvm7d {
  margin: 0;
}
.property_secondary.svelte-13fvm7d b.svelte-13fvm7d.svelte-13fvm7d {
  font-size: 22px;
}
.property_floors.svelte-13fvm7d.svelte-13fvm7d.svelte-13fvm7d {
  width: 70%;
  margin: 0 auto;
}
.property_floors.svelte-13fvm7d h3.svelte-13fvm7d.svelte-13fvm7d {
  font-size: 22px;
  margin: 0 0 15px 0;
  text-align: center;
}
.property_floors.svelte-13fvm7d .floor_lists.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  align-items: flex-start;
  gap: 35px;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item .left.svelte-13fvm7d.svelte-13fvm7d {
  flex-grow: 1;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item .left h5.svelte-13fvm7d.svelte-13fvm7d {
  font-size: 22px;
  text-transform: capitalize;
  font-weight: normal;
  margin: 0 0 15px 0;
  width: 100%;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_lists .floor_item .left.svelte-13fvm7d .room_lists.svelte-13fvm7d {
  font-size: 14px;
  width: 100%;
  color: #475569;
  border: 1px solid #CBD5E1;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item .left.svelte-13fvm7d .room_lists .room_item.svelte-13fvm7d {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  text-transform: capitalize;
  border-bottom: 1px solid #CBD5E1;
  padding: 5px 0;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item .floor_plan_image.svelte-13fvm7d.svelte-13fvm7d {
  width: 240px;
  height: 140px;
  position: relative;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid #CBD5E1;
  margin-top: 45px;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item .floor_plan_image img.svelte-13fvm7d.svelte-13fvm7d {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.property_floors.svelte-13fvm7d .floor_lists .floor_item .floor_plan_image .image_empty.svelte-13fvm7d.svelte-13fvm7d {
  border-radius: 8px;
  object-fit: cover;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: 8px;
  justify-content: center;
  align-items: center;
}
.property_history.svelte-13fvm7d .history_list.svelte-13fvm7d.svelte-13fvm7d {
  padding: 15px;
  background-color: rgb(0 0 0 / 0.06);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  min-height: 200px;
}
.property_history.svelte-13fvm7d .history_list .item.svelte-13fvm7d.svelte-13fvm7d {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  padding: 10px 0;
  border-bottom: 1px solid #CBD5E1;
  font-size: 15px;
  font-weight: 600;
}

/* fakecss:./guest/property/public.esbuild-svelte-fake-css */
.property_container.svelte-vm9pc0.svelte-vm9pc0 {
  width: 100%;
  margin: 30px auto 50px auto;
  color: #475569;
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 30px;
}
.property.svelte-vm9pc0.svelte-vm9pc0 {
  width: 60%;
}
.side_attribute.svelte-vm9pc0.svelte-vm9pc0 {
  width: 250px;
  height: fit-content;
  display: flex;
  flex-direction: column;
  gap: 20px;
}
.side_attribute.svelte-vm9pc0 .login_container.svelte-vm9pc0,
.side_attribute.svelte-vm9pc0 .share_container.svelte-vm9pc0 {
  text-align: center;
  height: fit-content;
  background-color: #F0F0F0;
  border-radius: 8px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.side_attribute.svelte-vm9pc0 .login_container h3.svelte-vm9pc0 {
  margin: 0 0 10px 0;
  font-size: 24px;
}
.side_attribute.svelte-vm9pc0 .login_container .login_btn.svelte-vm9pc0 {
  background-color: #6366F1;
  width: 100%;
  height: fit-content;
  padding: 12px;
  text-align: center;
  border-radius: 8px;
  color: #FFF;
  font-size: 13px;
  display: flex;
  flex-direction: row;
  gap: 6px;
  justify-content: center;
  align-items: center;
  text-decoration: none;
}
.side_attribute.svelte-vm9pc0 .login_container .login_btn.svelte-vm9pc0:hover {
  background-color: #7E80F1;
}
.side_attribute.svelte-vm9pc0 .share_container header.svelte-vm9pc0 {
  display: flex;
  flex-direction: row;
  justify-content: center;
  gap: 7px;
  align-items: center;
  font-size: 15px;
}
.side_attribute.svelte-vm9pc0 .share_container .share_options.svelte-vm9pc0 {
  display: grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  grid-template-rows: repeat(2, minmax(0, 1fr));
  align-items: center;
  justify-items: center;
  justify-content: center;
  align-content: center;
  row-gap: 12px;
}
.side_attribute.svelte-vm9pc0 .share_container .share_options .share_item.svelte-vm9pc0 {
  border: none;
  background: none;
  cursor: pointer;
}
.side_attribute .share_container .share_options .share_item:hover .share_icon {
  fill: #57667A !important;
}
</style>
<script>(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // _components/formatter.js
  var require_formatter = __commonJS({
    "_components/formatter.js"(exports, module) {
      function datetime(unixSec, humanize) {
        if (!unixSec)
          return "";
        if (typeof unixSec === "string")
          return unixSec;
        let dt = new Date(unixSec * 1e3);
        if (!humanize) {
          dt = dt.toISOString();
          return dt.substring(0, 10) + " " + dt.substring(11, 16);
        }
        const options = { day: "2-digit", month: "long", year: "numeric" };
        const formattedDate = dt.toLocaleDateString(void 0, options);
        return formattedDate;
      }
      function priceNtd(val) {
        return new Number(val).toLocaleString("zh-TW");
      }
      function localeDatetime2(unixSec) {
        if (!unixSec)
          return "";
        const dt = new Date(unixSec * 1e3);
        const day = dt.toLocaleDateString("default", { weekday: "long" });
        const date = dt.getDate();
        const month = dt.toLocaleDateString("default", { month: "long" });
        const year = dt.getFullYear();
        let hh = dt.getHours();
        if (hh < 10)
          hh = "0" + hh;
        let mm = dt.getMinutes();
        if (mm < 10)
          mm = "0" + mm;
        const formattedDate = `${day}, ${date} ${month} ${year} ${hh}:${mm}`;
        return formattedDate;
      }
      function datetime2(unixSec) {
        if (!unixSec)
          return "-";
        const dt = new Date(unixSec * 1e3);
        const year = dt.getFullYear();
        const month = dt.toLocaleDateString("default", { month: "long" });
        const day = dt.toLocaleDateString("default", { weekday: "long" });
        const date = String(dt.getDate()).padStart(2, "0");
        const hours = String(dt.getHours()).padStart(2, "0");
        const minutes = String(dt.getMinutes()).padStart(2, "0");
        const seconds = String(dt.getSeconds()).padStart(2, "0");
        return `${day}, ${date} ${month} ${year} - ${hours}:${minutes}:${seconds}`;
      }
      function formatPrice2(price, currency) {
        try {
          return new Intl.NumberFormat("en-US", {
            style: "currency",
            currency,
            maximumSignificantDigits: 3
          }).format(price);
        } catch (e) {
          console.log("formatPrice failed", e, price, currency);
          return price + " " + currency;
        }
      }
      module.exports = {
        datetime,
        priceNtd,
        localeDatetime: localeDatetime2,
        datetime2,
        formatPrice: formatPrice2
      };
    }
  });

  // node_modules/svelte/src/runtime/internal/utils.js
  function noop() {
  }
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return (
      /** @type {T & S} */
      tar
    );
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url) {
    if (element_src === url)
      return true;
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function null_to_empty(value) {
    return value == null ? "" : value;
  }

  // node_modules/svelte/src/runtime/internal/globals.js
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
    // @ts-ignore Node typings have this
    global
  );

  // node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
  var ResizeObserverSingleton = class {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    _listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
    /**
     * @private
     * @type {ResizeObserver}
     */
    _observer = void 0;
    /** @type {ResizeObserverOptions} */
    options;
    /** @param {ResizeObserverOptions} options */
    constructor(options) {
      this.options = options;
    }
    /**
     * @param {Element} element
     * @param {import('./private.js').Listener} listener
     * @returns {() => void}
     */
    observe(element2, listener) {
      this._listeners.set(element2, listener);
      this._getObserver().observe(element2, this.options);
      return () => {
        this._listeners.delete(element2);
        this._observer.unobserve(element2);
      };
    }
    /**
     * @private
     */
    _getObserver() {
      return this._observer ?? (this._observer = new ResizeObserver((entries) => {
        for (const entry of entries) {
          ResizeObserverSingleton.entries.set(entry.target, entry);
          this._listeners.get(entry.target)?.(entry);
        }
      }));
    }
  };
  ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

  // node_modules/svelte/src/runtime/internal/dom.js
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    if (node.parentNode) {
      node.parentNode.removeChild(node);
    }
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function svg_element(name) {
    return document.createElementNS("http://www.w3.org/2000/svg", name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function comment(content) {
    return document.createComment(content);
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
      attr(node, key, attributes[key]);
    }
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.data === data)
      return;
    text2.data = /** @type {string} */
    data;
  }
  function get_custom_elements_slots(element2) {
    const result = {};
    element2.childNodes.forEach(
      /** @param {Element} node */
      (node) => {
        result[node.slot || "default"] = true;
      }
    );
    return result;
  }

  // node_modules/svelte/src/runtime/internal/lifecycle.js
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  function get_current_component() {
    if (!current_component)
      throw new Error("Function called outside component initialization");
    return current_component;
  }
  function onMount(fn) {
    get_current_component().$.on_mount.push(fn);
  }

  // node_modules/svelte/src/runtime/internal/scheduler.js
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = /* @__PURE__ */ Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    if (flushidx !== 0) {
      return;
    }
    const saved_component = current_component;
    do {
      try {
        while (flushidx < dirty_components.length) {
          const component = dirty_components[flushidx];
          flushidx++;
          set_current_component(component);
          update(component.$);
        }
      } catch (e) {
        dirty_components.length = 0;
        flushidx = 0;
        throw e;
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($) {
    if ($.fragment !== null) {
      $.update();
      run_all($.before_update);
      const dirty = $.dirty;
      $.dirty = [-1];
      $.fragment && $.fragment.p($.ctx, dirty);
      $.after_update.forEach(add_render_callback);
    }
  }
  function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
  }

  // node_modules/svelte/src/runtime/internal/transitions.js
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
      // parent group
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    } else if (callback) {
      callback();
    }
  }

  // node_modules/svelte/src/runtime/internal/each.js
  function ensure_array_like(array_like_or_iterator) {
    return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
  }

  // node_modules/svelte/src/runtime/internal/spread.js
  function get_spread_update(levels, updates) {
    const update2 = {};
    const to_null_out = {};
    const accounted_for = { $scope: 1 };
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update2[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update2))
        update2[key] = void 0;
    }
    return update2;
  }

  // node_modules/svelte/src/shared/boolean_attributes.js
  var _boolean_attributes = (
    /** @type {const} */
    [
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]
  );
  var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

  // node_modules/svelte/src/runtime/internal/Component.js
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor) {
    const { fragment, after_update } = component.$;
    fragment && fragment.m(target, anchor);
    add_render_callback(() => {
      const new_on_destroy = component.$.on_mount.map(run).filter(is_function);
      if (component.$.on_destroy) {
        component.$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $ = component.$;
    if ($.fragment !== null) {
      flush_render_callbacks($.after_update);
      run_all($.on_destroy);
      $.fragment && $.fragment.d(detaching);
      $.on_destroy = $.fragment = null;
      $.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$.dirty.fill(0);
    }
    component.$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance6, create_fragment6, not_equal, props, append_styles = null, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $ = component.$ = {
      fragment: null,
      ctx: [],
      // state
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      // lifecycle
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$.context : [])),
      // everything else
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$.root
    };
    append_styles && append_styles($.root);
    let ready = false;
    $.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($.ctx && not_equal($.ctx[i], $.ctx[i] = value)) {
        if (!$.skip_bound && $.bound[i])
          $.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $.update();
    ready = true;
    run_all($.before_update);
    $.fragment = create_fragment6 ? create_fragment6($.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $.fragment && $.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $.fragment && $.fragment.c();
      }
      if (options.intro)
        transition_in(component.$.fragment);
      mount_component(component, options.target, options.anchor);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      /** The Svelte component constructor */
      $ctor;
      /** Slots */
      $s;
      /** The Svelte component instance */
      $c;
      /** Whether or not the custom element is connected */
      $cn = false;
      /** Component props data */
      $d = {};
      /** `true` if currently in the process of reflecting component props back to attributes */
      $r = false;
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      $p_d = {};
      /** @type {Record<string, Function[]>} Event listeners */
      $l = {};
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      $l_u = /* @__PURE__ */ new Map();
      constructor($componentCtor, $slots, use_shadow_dom) {
        super();
        this.$ctor = $componentCtor;
        this.$s = $slots;
        if (use_shadow_dom) {
          this.attachShadow({ mode: "open" });
        }
      }
      addEventListener(type, listener, options) {
        this.$l[type] = this.$l[type] || [];
        this.$l[type].push(listener);
        if (this.$c) {
          const unsub = this.$c.$on(type, listener);
          this.$l_u.set(listener, unsub);
        }
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
        if (this.$c) {
          const unsub = this.$l_u.get(listener);
          if (unsub) {
            unsub();
            this.$l_u.delete(listener);
          }
        }
      }
      async connectedCallback() {
        this.$cn = true;
        if (!this.$c) {
          let create_slot = function(name) {
            return () => {
              let node;
              const obj = {
                c: function create() {
                  node = element("slot");
                  if (name !== "default") {
                    attr(node, "name", name);
                  }
                },
                /**
                 * @param {HTMLElement} target
                 * @param {HTMLElement} [anchor]
                 */
                m: function mount(target, anchor) {
                  insert(target, node, anchor);
                },
                d: function destroy(detaching) {
                  if (detaching) {
                    detach(node);
                  }
                }
              };
              return obj;
            };
          };
          await Promise.resolve();
          if (!this.$cn) {
            return;
          }
          const $slots = {};
          const existing_slots = get_custom_elements_slots(this);
          for (const name of this.$s) {
            if (name in existing_slots) {
              $slots[name] = [create_slot(name)];
            }
          }
          for (const attribute of this.attributes) {
            const name = this.$g_p(attribute.name);
            if (!(name in this.$d)) {
              this.$d[name] = get_custom_element_value(name, attribute.value, this.$p_d, "toProp");
            }
          }
          this.$c = new this.$ctor({
            target: this.shadowRoot || this,
            props: {
              ...this.$d,
              $slots,
              $scope: {
                ctx: []
              }
            }
          });
          const reflect_attributes = () => {
            this.$r = true;
            for (const key in this.$p_d) {
              this.$d[key] = this.$c.$.ctx[this.$c.$.props[key]];
              if (this.$p_d[key].reflect) {
                const attribute_value = get_custom_element_value(
                  key,
                  this.$d[key],
                  this.$p_d,
                  "toAttribute"
                );
                if (attribute_value == null) {
                  this.removeAttribute(this.$p_d[key].attribute || key);
                } else {
                  this.setAttribute(this.$p_d[key].attribute || key, attribute_value);
                }
              }
            }
            this.$r = false;
          };
          this.$c.$.after_update.push(reflect_attributes);
          reflect_attributes();
          for (const type in this.$l) {
            for (const listener of this.$l[type]) {
              const unsub = this.$c.$on(type, listener);
              this.$l_u.set(listener, unsub);
            }
          }
          this.$l = {};
        }
      }
      // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
      // and setting attributes through setAttribute etc, this is helpful
      attributeChangedCallback(attr2, _oldValue, newValue) {
        if (this.$r)
          return;
        attr2 = this.$g_p(attr2);
        this.$d[attr2] = get_custom_element_value(attr2, newValue, this.$p_d, "toProp");
        this.$c?.$set({ [attr2]: this.$d[attr2] });
      }
      disconnectedCallback() {
        this.$cn = false;
        Promise.resolve().then(() => {
          if (!this.$cn) {
            this.$c.$destroy();
            this.$c = void 0;
          }
        });
      }
      $g_p(attribute_name) {
        return Object.keys(this.$p_d).find(
          (key) => this.$p_d[key].attribute === attribute_name || !this.$p_d[key].attribute && key.toLowerCase() === attribute_name
        ) || attribute_name;
      }
    };
  }
  function get_custom_element_value(prop, value, props_definition, transform) {
    const type = props_definition[prop]?.type;
    value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
    if (!transform || !props_definition[prop]) {
      return value;
    } else if (transform === "toAttribute") {
      switch (type) {
        case "Object":
        case "Array":
          return value == null ? null : JSON.stringify(value);
        case "Boolean":
          return value ? "" : null;
        case "Number":
          return value == null ? null : value;
        default:
          return value;
      }
    } else {
      switch (type) {
        case "Object":
        case "Array":
          return value && JSON.parse(value);
        case "Boolean":
          return value;
        case "Number":
          return value != null ? +value : value;
        default:
          return value;
      }
    }
  }
  var SvelteComponent = class {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $ = void 0;
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    $set = void 0;
    /** @returns {void} */
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    /**
     * @template {Extract<keyof Events, string>} K
     * @param {K} type
     * @param {((e: Events[K]) => void) | null | undefined} callback
     * @returns {() => void}
     */
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$.callbacks[type] || (this.$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    /**
     * @param {Partial<Props>} props
     * @returns {void}
     */
    $set(props) {
      if (this.$set && !is_empty(props)) {
        this.$.skip_bound = true;
        this.$set(props);
        this.$.skip_bound = false;
      }
    }
  };

  // node_modules/svelte/src/shared/version.js
  var PUBLIC_VERSION = "4";

  // node_modules/svelte/src/runtime/internal/disclose-version/index.js
  if (typeof window !== "undefined")
    (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

  // node_modules/svelte-icons-pack/Icon.svelte
  function create_fragment(ctx) {
    let svg;
    let svg_levels = [
      { width: (
        /*size*/
        ctx[1]
      ) },
      { height: (
        /*size*/
        ctx[1]
      ) },
      { "stroke-width": "0" },
      { class: (
        /*className*/
        ctx[2]
      ) },
      /*src*/
      ctx[0].a,
      /*attr*/
      ctx[4],
      { xmlns: "http://www.w3.org/2000/svg" }
    ];
    let svg_data = {};
    for (let i = 0; i < svg_levels.length; i += 1) {
      svg_data = assign(svg_data, svg_levels[i]);
    }
    return {
      c() {
        svg = svg_element("svg");
        set_svg_attributes(svg, svg_data);
      },
      m(target, anchor) {
        insert(target, svg, anchor);
        svg.innerHTML = /*innerHtml*/
        ctx[3];
      },
      p(ctx2, [dirty]) {
        if (dirty & /*innerHtml*/
        8)
          svg.innerHTML = /*innerHtml*/
          ctx2[3];
        ;
        set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
          dirty & /*size*/
          2 && { width: (
            /*size*/
            ctx2[1]
          ) },
          dirty & /*size*/
          2 && { height: (
            /*size*/
            ctx2[1]
          ) },
          { "stroke-width": "0" },
          dirty & /*className*/
          4 && { class: (
            /*className*/
            ctx2[2]
          ) },
          dirty & /*src*/
          1 && /*src*/
          ctx2[0].a,
          dirty & /*attr*/
          16 && /*attr*/
          ctx2[4],
          { xmlns: "http://www.w3.org/2000/svg" }
        ]));
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(svg);
        }
      }
    };
  }
  function instance($self, $props, $invalidate) {
    let { src } = $props;
    let { size = "1em" } = $props;
    let { color = void 0 } = $props;
    let { title = void 0 } = $props;
    let { className = "" } = $props;
    let innerHtml;
    let attr2;
    $self.$set = ($props2) => {
      if ("src" in $props2)
        $invalidate(0, src = $props2.src);
      if ("size" in $props2)
        $invalidate(1, size = $props2.size);
      if ("color" in $props2)
        $invalidate(5, color = $props2.color);
      if ("title" in $props2)
        $invalidate(6, title = $props2.title);
      if ("className" in $props2)
        $invalidate(2, className = $props2.className);
    };
    $self.$.update = () => {
      if ($self.$.dirty & /*color, src*/
      33) {
        $: {
          $invalidate(4, attr2 = {});
          if (color) {
            if (src.a.stroke !== "none") {
              $invalidate(4, attr2.stroke = color, attr2);
            }
            if (src.a.fill !== "none") {
              $invalidate(4, attr2.fill = color, attr2);
            }
          }
        }
      }
      if ($self.$.dirty & /*title, src*/
      65) {
        $: {
          $invalidate(3, innerHtml = (title ? `<title>${title}</title>` : "") + src.c);
        }
      }
    };
    return [src, size, className, innerHtml, attr2, color, title];
  }
  var Icon = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, {
        src: 0,
        size: 1,
        color: 5,
        title: 6,
        className: 2
      });
    }
  };
  var Icon_default = Icon;

  // node_modules/svelte-icons-pack/fa/FaSolidInfoCircle.js
  var FaSolidInfoCircle_default = {
    a: {
      viewBox: "0 0 512 512"
    },
    c: '<path d="M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaSolidCheckCircle.js
  var FaSolidCheckCircle_default = {
    a: {
      viewBox: "0 0 512 512"
    },
    c: '<path d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaSolidExclamationTriangle.js
  var FaSolidExclamationTriangle_default = {
    a: {
      viewBox: "0 0 576 512"
    },
    c: '<path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaSolidTimesCircle.js
  var FaSolidTimesCircle_default = {
    a: {
      viewBox: "0 0 512 512"
    },
    c: '<path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"></path>'
  };

  // _components/Growl.svelte
  function create_fragment2(ctx) {
    let div;
    let icon_1;
    let t0;
    let span;
    let t1;
    let div_class_value;
    let current;
    icon_1 = new Icon_default({
      props: {
        className: "icon_growl",
        size: 20,
        color: "#FFF",
        src: (
          /*icon*/
          ctx[3]
        )
      }
    });
    return {
      c() {
        div = element("div");
        create_component(icon_1.$.fragment);
        t0 = space();
        span = element("span");
        t1 = text(
          /*message*/
          ctx[0]
        );
        attr(span, "class", "svelte-1nas9kk");
        attr(div, "class", div_class_value = null_to_empty(`growl ${/*growlType*/
        ctx[1]} ${/*isShow*/
        ctx[2] ? "" : "hidden"}`) + " svelte-1nas9kk");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(icon_1, div, null);
        append(div, t0);
        append(div, span);
        append(span, t1);
        current = true;
      },
      p(ctx2, [dirty]) {
        const icon_1_changes = {};
        if (dirty & /*icon*/
        8)
          icon_1_changes.src = /*icon*/
          ctx2[3];
        icon_1.$set(icon_1_changes);
        if (!current || dirty & /*message*/
        1)
          set_data(
            t1,
            /*message*/
            ctx2[0]
          );
        if (!current || dirty & /*growlType, isShow*/
        6 && div_class_value !== (div_class_value = null_to_empty(`growl ${/*growlType*/
        ctx2[1]} ${/*isShow*/
        ctx2[2] ? "" : "hidden"}`) + " svelte-1nas9kk")) {
          attr(div, "class", div_class_value);
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(icon_1.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(icon_1.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(icon_1);
      }
    };
  }
  function instance2($self, $props, $invalidate) {
    let message = "This is growl, XD";
    let growlType = "info";
    let isShow = false;
    let icon = FaSolidInfoCircle_default;
    function show(msg, typ, ico) {
      $invalidate(3, icon = ico);
      $invalidate(1, growlType = typ);
      $invalidate(2, isShow = true);
      $invalidate(0, message = msg);
      setTimeout(
        () => {
          $invalidate(2, isShow = false);
        },
        3e3
      );
    }
    const showInfo = function(msg) {
      console.log("grow.showInfo", msg);
      show(msg, "info", FaSolidInfoCircle_default);
    };
    const showWarning = function(msg) {
      console.log("grow.showWarning", msg);
      show(msg, "warning", FaSolidExclamationTriangle_default);
    };
    const showError = function(msg) {
      console.log("grow.showError", msg);
      show(msg, "error", FaSolidTimesCircle_default);
    };
    const showSuccess = function(msg) {
      console.log("grow.showSuccess", msg);
      show(msg, "success", FaSolidCheckCircle_default);
    };
    return [
      message,
      growlType,
      isShow,
      icon,
      showInfo,
      showWarning,
      showError,
      showSuccess
    ];
  }
  var Growl = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment2, safe_not_equal, {
        showInfo: 4,
        showWarning: 5,
        showError: 6,
        showSuccess: 7
      });
    }
    get showInfo() {
      return this.$.ctx[4];
    }
    get showWarning() {
      return this.$.ctx[5];
    }
    get showError() {
      return this.$.ctx[6];
    }
    get showSuccess() {
      return this.$.ctx[7];
    }
  };
  var Growl_default = Growl;

  // node_modules/svelte-icons-pack/fa/FaSolidArrowRight.js
  var FaSolidArrowRight_default = {
    a: {
      viewBox: "0 0 448 512"
    },
    c: '<path d="M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaSolidShareAlt.js
  var FaSolidShareAlt_default = {
    a: {
      viewBox: "0 0 448 512"
    },
    c: '<path d="M352 320c-22.608 0-43.387 7.819-59.79 20.895l-102.486-64.054a96.551 96.551 0 0 0 0-41.683l102.486-64.054C308.613 184.181 329.392 192 352 192c53.019 0 96-42.981 96-96S405.019 0 352 0s-96 42.981-96 96c0 7.158.79 14.13 2.276 20.841L155.79 180.895C139.387 167.819 118.608 160 96 160c-53.019 0-96 42.981-96 96s42.981 96 96 96c22.608 0 43.387-7.819 59.79-20.895l102.486 64.054A96.301 96.301 0 0 0 256 416c0 53.019 42.981 96 96 96s96-42.981 96-96-42.981-96-96-96z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaCopy.js
  var FaCopy_default = {
    a: {
      viewBox: "0 0 448 512"
    },
    c: '<path d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaBrandsFacebook.js
  var FaBrandsFacebook_default = {
    a: {
      viewBox: "0 0 512 512"
    },
    c: '<path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaBrandsLinkedin.js
  var FaBrandsLinkedin_default = {
    a: {
      viewBox: "0 0 448 512"
    },
    c: '<path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaBrandsTwitter.js
  var FaBrandsTwitter_default = {
    a: {
      viewBox: "0 0 512 512"
    },
    c: '<path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaBrandsWhatsapp.js
  var FaBrandsWhatsapp_default = {
    a: {
      viewBox: "0 0 448 512"
    },
    c: '<path d="M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaBrandsTelegram.js
  var FaBrandsTelegram_default = {
    a: {
      viewBox: "0 0 496 512"
    },
    c: '<path d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaSolidImage.js
  var FaSolidImage_default = {
    a: {
      viewBox: "0 0 512 512"
    },
    c: '<path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path>'
  };

  // node_modules/svelte-icons-pack/fa/FaSolidHome.js
  var FaSolidHome_default = {
    a: {
      viewBox: "0 0 576 512"
    },
    c: '<path d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path>'
  };

  // _components/Property.svelte
  var import_formatter = __toESM(require_formatter());

  // node_modules/svelte-icons-pack/fa/FaSolidMapMarkerAlt.js
  var FaSolidMapMarkerAlt_default = {
    a: {
      viewBox: "0 0 384 512"
    },
    c: '<path d="M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z"></path>'
  };

  // _components/PillBox.svelte
  function create_fragment3(ctx) {
    let span2;
    let span0;
    let t0;
    let t1;
    let span1;
    let t2;
    return {
      c() {
        span2 = element("span");
        span0 = element("span");
        t0 = text(
          /*label*/
          ctx[0]
        );
        t1 = space();
        span1 = element("span");
        t2 = text(
          /*content*/
          ctx[1]
        );
        attr(span0, "class", "pill-box-left svelte-1x7s25u");
        attr(span1, "class", "pill-box-right svelte-1x7s25u");
        attr(span2, "class", "pill-box pill-blue svelte-1x7s25u");
      },
      m(target, anchor) {
        insert(target, span2, anchor);
        append(span2, span0);
        append(span0, t0);
        append(span2, t1);
        append(span2, span1);
        append(span1, t2);
      },
      p(ctx2, [dirty]) {
        if (dirty & /*label*/
        1)
          set_data(
            t0,
            /*label*/
            ctx2[0]
          );
        if (dirty & /*content*/
        2)
          set_data(
            t2,
            /*content*/
            ctx2[1]
          );
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(span2);
        }
      }
    };
  }
  function instance3($self, $props, $invalidate) {
    let { label = "label" } = $props;
    let { content = "content" } = $props;
    $self.$set = ($props2) => {
      if ("label" in $props2)
        $invalidate(0, label = $props2.label);
      if ("content" in $props2)
        $invalidate(1, content = $props2.content);
    };
    return [label, content];
  }
  var PillBox = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment3, safe_not_equal, { label: 0, content: 1 });
    }
  };
  var PillBox_default = PillBox;

  // _components/Property.svelte
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[5] = list[i];
    return child_ctx;
  }
  function get_each_context_1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[8] = list[i];
    return child_ctx;
  }
  function get_each_context_2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[11] = list[i];
    return child_ctx;
  }
  function get_each_context_3(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[14] = list[i];
    return child_ctx;
  }
  function get_each_context_4(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[17] = list[i];
    return child_ctx;
  }
  function create_else_block_2(ctx) {
    let div;
    let icon;
    let t0;
    let span;
    let current;
    icon = new Icon_default({
      props: {
        size: 40,
        color: "#475569",
        src: FaSolidImage_default
      }
    });
    return {
      c() {
        div = element("div");
        create_component(icon.$.fragment);
        t0 = space();
        span = element("span");
        span.textContent = "No Image !";
        attr(span, "class", "svelte-13fvm7d");
        attr(div, "class", "image_empty svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(icon, div, null);
        append(div, t0);
        append(div, span);
        current = true;
      },
      p: noop,
      i(local) {
        if (current)
          return;
        transition_in(icon.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(icon.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(icon);
      }
    };
  }
  function create_if_block_7(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*propItem*/
        ctx[1].images[0]))
          attr(img, "src", img_src_value);
        attr(img, "alt", "");
        attr(img, "class", "svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && !src_url_equal(img.src, img_src_value = /*propItem*/
        ctx2[1].images[0])) {
          attr(img, "src", img_src_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  function create_if_block_6(ctx) {
    let span;
    let t_value = (
      /*s*/
      ctx[17].sign + " Property is " + /*s*/
      ctx[17].status
    );
    let t;
    let span_class_value;
    return {
      c() {
        span = element("span");
        t = text(t_value);
        attr(span, "class", span_class_value = null_to_empty(`prop_status ${/*s*/
        ctx[17].status}`) + " svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, span, anchor);
        append(span, t);
      },
      p: noop,
      d(detaching) {
        if (detaching) {
          detach(span);
        }
      }
    };
  }
  function create_each_block_4(ctx) {
    let if_block_anchor;
    let if_block = (
      /*s*/
      ctx[17].status === /*approvalStatus*/
      ctx[3] && /*s*/
      ctx[17].status !== "approved" && create_if_block_6(ctx)
    );
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, dirty) {
        if (
          /*s*/
          ctx2[17].status === /*approvalStatus*/
          ctx2[3] && /*s*/
          ctx2[17].status !== "approved"
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block_6(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block)
          if_block.d(detaching);
      }
    };
  }
  function create_if_block_4(ctx) {
    let current_block_type_index;
    let if_block;
    let if_block_anchor;
    let current;
    const if_block_creators = [create_if_block_5, create_else_block_1];
    const if_blocks = [];
    function select_block_type_1(ctx2, dirty) {
      if (
        /*m*/
        ctx2[14].inputType === "datetime"
      )
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type_1(ctx, -1);
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if_blocks[current_block_type_index].m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_1(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if_blocks[current_block_type_index].d(detaching);
      }
    };
  }
  function create_else_block_1(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[14].label
        ),
        content: (
          /*propItem*/
          ctx[1][
            /*m*/
            ctx[14].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[14].label;
        if (dirty & /*propItem, meta*/
        6)
          pillbox_changes.content = /*propItem*/
          ctx2[1][
            /*m*/
            ctx2[14].name
          ];
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_if_block_5(ctx) {
    let pillbox;
    let current;
    pillbox = new PillBox_default({
      props: {
        label: (
          /*m*/
          ctx[14].label
        ),
        content: (0, import_formatter.localeDatetime)(
          /*propItem*/
          ctx[1][
            /*m*/
            ctx[14].name
          ]
        )
      }
    });
    return {
      c() {
        create_component(pillbox.$.fragment);
      },
      m(target, anchor) {
        mount_component(pillbox, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const pillbox_changes = {};
        if (dirty & /*meta*/
        4)
          pillbox_changes.label = /*m*/
          ctx2[14].label;
        if (dirty & /*propItem, meta*/
        6)
          pillbox_changes.content = (0, import_formatter.localeDatetime)(
            /*propItem*/
            ctx2[1][
              /*m*/
              ctx2[14].name
            ]
          );
        pillbox.$set(pillbox_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(pillbox.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(pillbox.$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(pillbox, detaching);
      }
    };
  }
  function create_each_block_3(ctx) {
    let if_block_anchor;
    let current;
    let if_block = (
      /*propItem*/
      ctx[1][
        /*m*/
        ctx[14].name
      ] && create_if_block_4(ctx)
    );
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        if (
          /*propItem*/
          ctx2[1][
            /*m*/
            ctx2[14].name
          ]
        ) {
          if (if_block) {
            if_block.p(ctx2, dirty);
            if (dirty & /*propItem, meta*/
            6) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block_4(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block);
        current = true;
      },
      o(local) {
        transition_out(if_block);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(if_block_anchor);
        }
        if (if_block)
          if_block.d(detaching);
      }
    };
  }
  function create_if_block_1(ctx) {
    let div1;
    let h3;
    let t1;
    let div0;
    let current;
    let each_value_1 = ensure_array_like(
      /*propItem*/
      ctx[1].floorList
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    });
    return {
      c() {
        div1 = element("div");
        h3 = element("h3");
        h3.textContent = "Floors";
        t1 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h3, "class", "svelte-13fvm7d");
        attr(div0, "class", "floor_lists svelte-13fvm7d");
        attr(div1, "class", "property_floors svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h3);
        append(div1, t1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
        current = true;
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2) {
          each_value_1 = ensure_array_like(
            /*propItem*/
            ctx2[1].floorList
          );
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_1(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div0, null);
            }
          }
          group_outros();
          for (i = each_value_1.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        for (let i = 0; i < each_value_1.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_if_block_3(ctx) {
    let div;
    let each_value_2 = ensure_array_like(
      /*floors*/
      ctx[8].rooms
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_2.length; i += 1) {
      each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    }
    return {
      c() {
        div = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div, "class", "room_lists svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2) {
          each_value_2 = ensure_array_like(
            /*floors*/
            ctx2[8].rooms
          );
          let i;
          for (i = 0; i < each_value_2.length; i += 1) {
            const child_ctx = get_each_context_2(ctx2, each_value_2, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block_2(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value_2.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block_2(ctx) {
    let div;
    let span0;
    let t0_value = (
      /*room*/
      (ctx[11].name || "-") + ""
    );
    let t0;
    let t1;
    let span1;
    let t2_value = (
      /*room*/
      (ctx[11].sizeM2 || "-") + ""
    );
    let t2;
    let t3;
    let t4;
    return {
      c() {
        div = element("div");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = text(t2_value);
        t3 = text(" M2");
        t4 = space();
        attr(div, "class", "room_item svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span0);
        append(span0, t0);
        append(div, t1);
        append(div, span1);
        append(span1, t2);
        append(span1, t3);
        append(div, t4);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && t0_value !== (t0_value = /*room*/
        (ctx2[11].name || "-") + ""))
          set_data(t0, t0_value);
        if (dirty & /*propItem*/
        2 && t2_value !== (t2_value = /*room*/
        (ctx2[11].sizeM2 || "-") + ""))
          set_data(t2, t2_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_else_block(ctx) {
    let img;
    let img_src_value;
    return {
      c() {
        img = element("img");
        if (!src_url_equal(img.src, img_src_value = /*floors*/
        ctx[8].planImageUrl))
          attr(img, "src", img_src_value);
        attr(img, "alt", "");
        attr(img, "class", "svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, img, anchor);
      },
      p(ctx2, dirty) {
        if (dirty & /*propItem*/
        2 && !src_url_equal(img.src, img_src_value = /*floors*/
        ctx2[8].planImageUrl)) {
          attr(img, "src", img_src_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching) {
          detach(img);
        }
      }
    };
  }
  function create_if_block_2(ctx) {
    let div;
    let icon;
    let t0;
    let span;
    let current;
    icon = new Icon_default({
      props: {
        size: 30,
        color: "#475569",
        src: FaSolidImage_default
      }
    });
    return {
      c() {
        div = element("div");
        create_component(icon.$.fragment);
        t0 = space();
        span = element("span");
        span.textContent = "No Image !";
        attr(div, "class", "image_empty svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        mount_component(icon, div, null);
        append(div, t0);
        append(div, span);
        current = true;
      },
      p: noop,
      i(local) {
        if (current)
          return;
        transition_in(icon.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(icon.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
        destroy_component(icon);
      }
    };
  }
  function create_each_block_1(ctx) {
    let div2;
    let div0;
    let h5;
    let t0_value = (
      /*floors*/
      ctx[8].type === "basement" ? "Basement" : `Floor #${/*floors*/
      ctx[8].floor}`
    );
    let t0;
    let t1;
    let c;
    let t2;
    let t3;
    let div1;
    let current_block_type_index;
    let if_block1;
    let t4;
    let current;
    let if_block0 = (
      /*floors*/
      ctx[8].rooms && create_if_block_3(ctx)
    );
    const if_block_creators = [create_if_block_2, create_else_block];
    const if_blocks = [];
    function select_block_type_2(ctx2, dirty) {
      if (
        /*floors*/
        ctx2[8].planImageUrl === ""
      )
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type_2(ctx, -1);
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    return {
      c() {
        div2 = element("div");
        div0 = element("div");
        h5 = element("h5");
        t0 = text(t0_value);
        t1 = space();
        c = comment(" TODO: currently room list only 1 object, fix Tarantool to accept array ");
        t2 = space();
        if (if_block0)
          if_block0.c();
        t3 = space();
        div1 = element("div");
        if_block1.c();
        t4 = space();
        attr(h5, "class", "svelte-13fvm7d");
        attr(div0, "class", "left svelte-13fvm7d");
        attr(div1, "class", "floor_plan_image svelte-13fvm7d");
        attr(div2, "class", "floor_item svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div2, anchor);
        append(div2, div0);
        append(div0, h5);
        append(h5, t0);
        append(div0, t1);
        append(div0, c);
        append(div0, t2);
        if (if_block0)
          if_block0.m(div0, null);
        append(div2, t3);
        append(div2, div1);
        if_blocks[current_block_type_index].m(div1, null);
        append(div2, t4);
        current = true;
      },
      p(ctx2, dirty) {
        if ((!current || dirty & /*propItem*/
        2) && t0_value !== (t0_value = /*floors*/
        ctx2[8].type === "basement" ? "Basement" : `Floor #${/*floors*/
        ctx2[8].floor}`))
          set_data(t0, t0_value);
        if (
          /*floors*/
          ctx2[8].rooms
        ) {
          if (if_block0) {
            if_block0.p(ctx2, dirty);
          } else {
            if_block0 = create_if_block_3(ctx2);
            if_block0.c();
            if_block0.m(div0, null);
          }
        } else if (if_block0) {
          if_block0.d(1);
          if_block0 = null;
        }
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type_2(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div2);
        }
        if (if_block0)
          if_block0.d();
        if_blocks[current_block_type_index].d();
      }
    };
  }
  function create_if_block(ctx) {
    let div1;
    let h3;
    let t1;
    let div0;
    let each_value = ensure_array_like(
      /*propHistories*/
      ctx[0]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    return {
      c() {
        div1 = element("div");
        h3 = element("h3");
        h3.textContent = "Price History";
        t1 = space();
        div0 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(h3, "class", "svelte-13fvm7d");
        attr(div0, "class", "history_list svelte-13fvm7d");
        attr(div1, "class", "property_history svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div1, anchor);
        append(div1, h3);
        append(div1, t1);
        append(div1, div0);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div0, null);
          }
        }
      },
      p(ctx2, dirty) {
        if (dirty & /*propHistories*/
        1) {
          each_value = ensure_array_like(
            /*propHistories*/
            ctx2[0]
          );
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div0, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      d(detaching) {
        if (detaching) {
          detach(div1);
        }
        destroy_each(each_blocks, detaching);
      }
    };
  }
  function create_each_block(ctx) {
    let div;
    let span0;
    let t0_value = (0, import_formatter.formatPrice)(
      /*ph*/
      ctx[5].price || /*ph*/
      ctx[5].priceNtd,
      "TWD"
    ) + "";
    let t0;
    let t1;
    let span1;
    let t2_value = (0, import_formatter.localeDatetime)(
      /*ph*/
      ctx[5].updatedAt
    ) + "";
    let t2;
    let t3;
    return {
      c() {
        div = element("div");
        span0 = element("span");
        t0 = text(t0_value);
        t1 = space();
        span1 = element("span");
        t2 = text(t2_value);
        t3 = space();
        attr(div, "class", "item svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, span0);
        append(span0, t0);
        append(div, t1);
        append(div, span1);
        append(span1, t2);
        append(div, t3);
      },
      p(ctx2, dirty) {
        if (dirty & /*propHistories*/
        1 && t0_value !== (t0_value = (0, import_formatter.formatPrice)(
          /*ph*/
          ctx2[5].price || /*ph*/
          ctx2[5].priceNtd,
          "TWD"
        ) + ""))
          set_data(t0, t0_value);
        if (dirty & /*propHistories*/
        1 && t2_value !== (t2_value = (0, import_formatter.localeDatetime)(
          /*ph*/
          ctx2[5].updatedAt
        ) + ""))
          set_data(t2, t2_value);
      },
      d(detaching) {
        if (detaching) {
          detach(div);
        }
      }
    };
  }
  function create_fragment4(ctx) {
    let div16;
    let div8;
    let div0;
    let current_block_type_index;
    let if_block0;
    let t0;
    let div7;
    let div4;
    let div3;
    let div1;
    let t1_value = (
      /*propItem*/
      ctx[1].purpose === "rent" ? "For Rent" : "On Sale"
    );
    let t1;
    let div1_class_value;
    let t2;
    let div2;
    let icon0;
    let t3;
    let span0;
    let t4_value = (
      /*propItem*/
      (ctx[1].houseType === "" ? "House" : (
        /*propItem*/
        ctx[1].houseType
      )) + ""
    );
    let t4;
    let t5;
    let t6;
    let div6;
    let h1;
    let t7_value = ((0, import_formatter.formatPrice)(
      /*propItem*/
      ctx[1].lastPrice,
      "TWD"
    ) || "0.00") + "";
    let t7;
    let t8;
    let p0;
    let t9;
    let t10_value = (
      /*propItem*/
      ctx[1].agencyFeePercent + ""
    );
    let t10;
    let t11;
    let t12;
    let div5;
    let icon1;
    let t13;
    let span1;
    let t14_value = (
      /*propItem*/
      (ctx[1].formattedAddress === "" ? (
        /*propItem*/
        ctx[1].address
      ) : (
        /*propItem*/
        ctx[1].formattedAddress
      )) + ""
    );
    let t14;
    let t15;
    let div14;
    let div13;
    let div9;
    let b0;
    let t16_value = (
      /*propItem*/
      (ctx[1].numberOfFloors || "0") + ""
    );
    let t16;
    let t17;
    let p1;
    let t19;
    let div10;
    let b1;
    let t20_value = (
      /*propItem*/
      (ctx[1].bathroom || "0") + ""
    );
    let t20;
    let t21;
    let p2;
    let t23;
    let div11;
    let b2;
    let t24_value = (
      /*propItem*/
      (ctx[1].bedroom || "0") + ""
    );
    let t24;
    let t25;
    let p3;
    let t27;
    let div12;
    let b3;
    let t28_value = (
      /*propItem*/
      (ctx[1].sizeM2 || "0") + ""
    );
    let t28;
    let t29;
    let t30;
    let p4;
    let t32;
    let div15;
    let t33;
    let t34;
    let current;
    const if_block_creators = [create_if_block_7, create_else_block_2];
    const if_blocks = [];
    function select_block_type(ctx2, dirty) {
      if (
        /*propItem*/
        ctx2[1].images && /*propItem*/
        ctx2[1].images.length
      )
        return 0;
      return 1;
    }
    current_block_type_index = select_block_type(ctx, -1);
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    icon0 = new Icon_default({
      props: {
        color: "#FFF",
        size: 16,
        src: FaSolidHome_default
      }
    });
    let each_value_4 = ensure_array_like(
      /*signs*/
      ctx[4]
    );
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_4.length; i += 1) {
      each_blocks_1[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    }
    icon1 = new Icon_default({
      props: {
        className: "icon_address",
        color: "#f97316",
        size: 18,
        src: FaSolidMapMarkerAlt_default
      }
    });
    let each_value_3 = ensure_array_like(
      /*meta*/
      ctx[2]
    );
    let each_blocks = [];
    for (let i = 0; i < each_value_3.length; i += 1) {
      each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    }
    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    });
    let if_block1 = (
      /*propItem*/
      ctx[1].floorList && /*propItem*/
      ctx[1].floorList.length && create_if_block_1(ctx)
    );
    let if_block2 = (
      /*propHistories*/
      ctx[0] && /*propHistories*/
      ctx[0].length && create_if_block(ctx)
    );
    return {
      c() {
        div16 = element("div");
        div8 = element("div");
        div0 = element("div");
        if_block0.c();
        t0 = space();
        div7 = element("div");
        div4 = element("div");
        div3 = element("div");
        div1 = element("div");
        t1 = text(t1_value);
        t2 = space();
        div2 = element("div");
        create_component(icon0.$.fragment);
        t3 = space();
        span0 = element("span");
        t4 = text(t4_value);
        t5 = space();
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t6 = space();
        div6 = element("div");
        h1 = element("h1");
        t7 = text(t7_value);
        t8 = space();
        p0 = element("p");
        t9 = text("Agency Fee : ");
        t10 = text(t10_value);
        t11 = text("%");
        t12 = space();
        div5 = element("div");
        create_component(icon1.$.fragment);
        t13 = space();
        span1 = element("span");
        t14 = text(t14_value);
        t15 = space();
        div14 = element("div");
        div13 = element("div");
        div9 = element("div");
        b0 = element("b");
        t16 = text(t16_value);
        t17 = space();
        p1 = element("p");
        p1.textContent = "Floors";
        t19 = space();
        div10 = element("div");
        b1 = element("b");
        t20 = text(t20_value);
        t21 = space();
        p2 = element("p");
        p2.textContent = "Baths";
        t23 = space();
        div11 = element("div");
        b2 = element("b");
        t24 = text(t24_value);
        t25 = space();
        p3 = element("p");
        p3.textContent = "Beds";
        t27 = space();
        div12 = element("div");
        b3 = element("b");
        t28 = text(t28_value);
        t29 = text(" M2");
        t30 = space();
        p4 = element("p");
        p4.textContent = "Size";
        t32 = space();
        div15 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        t33 = space();
        if (if_block1)
          if_block1.c();
        t34 = space();
        if (if_block2)
          if_block2.c();
        attr(div0, "class", "property_images svelte-13fvm7d");
        attr(div1, "class", div1_class_value = null_to_empty(
          /*propItem*/
          ctx[1].purpose === "rent" ? `purpose label_rent` : `purpose label_sale`
        ) + " svelte-13fvm7d");
        attr(span0, "class", "svelte-13fvm7d");
        attr(div2, "class", "house_type svelte-13fvm7d");
        attr(div3, "class", "left svelte-13fvm7d");
        attr(div4, "class", "col1 svelte-13fvm7d");
        attr(h1, "class", "svelte-13fvm7d");
        attr(p0, "class", "svelte-13fvm7d");
        attr(span1, "class", "svelte-13fvm7d");
        attr(div5, "class", "address svelte-13fvm7d");
        attr(div6, "class", "col2 svelte-13fvm7d");
        attr(div7, "class", "property_info svelte-13fvm7d");
        attr(div8, "class", "property_main svelte-13fvm7d");
        attr(b0, "class", "svelte-13fvm7d");
        attr(p1, "class", "svelte-13fvm7d");
        attr(div9, "class", "feature_item svelte-13fvm7d");
        attr(b1, "class", "svelte-13fvm7d");
        attr(p2, "class", "svelte-13fvm7d");
        attr(div10, "class", "feature_item svelte-13fvm7d");
        attr(b2, "class", "svelte-13fvm7d");
        attr(p3, "class", "svelte-13fvm7d");
        attr(div11, "class", "feature_item svelte-13fvm7d");
        attr(b3, "class", "svelte-13fvm7d");
        attr(p4, "class", "svelte-13fvm7d");
        attr(div12, "class", "feature_item svelte-13fvm7d");
        attr(div13, "class", "feature_number svelte-13fvm7d");
        attr(div14, "class", "property_secondary svelte-13fvm7d");
        attr(div15, "class", "property_attributes");
        attr(div16, "class", "property svelte-13fvm7d");
      },
      m(target, anchor) {
        insert(target, div16, anchor);
        append(div16, div8);
        append(div8, div0);
        if_blocks[current_block_type_index].m(div0, null);
        append(div8, t0);
        append(div8, div7);
        append(div7, div4);
        append(div4, div3);
        append(div3, div1);
        append(div1, t1);
        append(div3, t2);
        append(div3, div2);
        mount_component(icon0, div2, null);
        append(div2, t3);
        append(div2, span0);
        append(span0, t4);
        append(div4, t5);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          if (each_blocks_1[i]) {
            each_blocks_1[i].m(div4, null);
          }
        }
        append(div7, t6);
        append(div7, div6);
        append(div6, h1);
        append(h1, t7);
        append(div6, t8);
        append(div6, p0);
        append(p0, t9);
        append(p0, t10);
        append(p0, t11);
        append(div6, t12);
        append(div6, div5);
        mount_component(icon1, div5, null);
        append(div5, t13);
        append(div5, span1);
        append(span1, t14);
        append(div16, t15);
        append(div16, div14);
        append(div14, div13);
        append(div13, div9);
        append(div9, b0);
        append(b0, t16);
        append(div9, t17);
        append(div9, p1);
        append(div13, t19);
        append(div13, div10);
        append(div10, b1);
        append(b1, t20);
        append(div10, t21);
        append(div10, p2);
        append(div13, t23);
        append(div13, div11);
        append(div11, b2);
        append(b2, t24);
        append(div11, t25);
        append(div11, p3);
        append(div13, t27);
        append(div13, div12);
        append(div12, b3);
        append(b3, t28);
        append(b3, t29);
        append(div12, t30);
        append(div12, p4);
        append(div16, t32);
        append(div16, div15);
        for (let i = 0; i < each_blocks.length; i += 1) {
          if (each_blocks[i]) {
            each_blocks[i].m(div15, null);
          }
        }
        append(div16, t33);
        if (if_block1)
          if_block1.m(div16, null);
        append(div16, t34);
        if (if_block2)
          if_block2.m(div16, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        let previous_block_index = current_block_type_index;
        current_block_type_index = select_block_type(ctx2, dirty);
        if (current_block_type_index === previous_block_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        } else {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
        if ((!current || dirty & /*propItem*/
        2) && t1_value !== (t1_value = /*propItem*/
        ctx2[1].purpose === "rent" ? "For Rent" : "On Sale"))
          set_data(t1, t1_value);
        if (!current || dirty & /*propItem*/
        2 && div1_class_value !== (div1_class_value = null_to_empty(
          /*propItem*/
          ctx2[1].purpose === "rent" ? `purpose label_rent` : `purpose label_sale`
        ) + " svelte-13fvm7d")) {
          attr(div1, "class", div1_class_value);
        }
        if ((!current || dirty & /*propItem*/
        2) && t4_value !== (t4_value = /*propItem*/
        (ctx2[1].houseType === "" ? "House" : (
          /*propItem*/
          ctx2[1].houseType
        )) + ""))
          set_data(t4, t4_value);
        if (dirty & /*signs, approvalStatus*/
        24) {
          each_value_4 = ensure_array_like(
            /*signs*/
            ctx2[4]
          );
          let i;
          for (i = 0; i < each_value_4.length; i += 1) {
            const child_ctx = get_each_context_4(ctx2, each_value_4, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_4(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div4, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_4.length;
        }
        if ((!current || dirty & /*propItem*/
        2) && t7_value !== (t7_value = ((0, import_formatter.formatPrice)(
          /*propItem*/
          ctx2[1].lastPrice,
          "TWD"
        ) || "0.00") + ""))
          set_data(t7, t7_value);
        if ((!current || dirty & /*propItem*/
        2) && t10_value !== (t10_value = /*propItem*/
        ctx2[1].agencyFeePercent + ""))
          set_data(t10, t10_value);
        if ((!current || dirty & /*propItem*/
        2) && t14_value !== (t14_value = /*propItem*/
        (ctx2[1].formattedAddress === "" ? (
          /*propItem*/
          ctx2[1].address
        ) : (
          /*propItem*/
          ctx2[1].formattedAddress
        )) + ""))
          set_data(t14, t14_value);
        if ((!current || dirty & /*propItem*/
        2) && t16_value !== (t16_value = /*propItem*/
        (ctx2[1].numberOfFloors || "0") + ""))
          set_data(t16, t16_value);
        if ((!current || dirty & /*propItem*/
        2) && t20_value !== (t20_value = /*propItem*/
        (ctx2[1].bathroom || "0") + ""))
          set_data(t20, t20_value);
        if ((!current || dirty & /*propItem*/
        2) && t24_value !== (t24_value = /*propItem*/
        (ctx2[1].bedroom || "0") + ""))
          set_data(t24, t24_value);
        if ((!current || dirty & /*propItem*/
        2) && t28_value !== (t28_value = /*propItem*/
        (ctx2[1].sizeM2 || "0") + ""))
          set_data(t28, t28_value);
        if (dirty & /*meta, propItem*/
        6) {
          each_value_3 = ensure_array_like(
            /*meta*/
            ctx2[2]
          );
          let i;
          for (i = 0; i < each_value_3.length; i += 1) {
            const child_ctx = get_each_context_3(ctx2, each_value_3, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block_3(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div15, null);
            }
          }
          group_outros();
          for (i = each_value_3.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
        if (
          /*propItem*/
          ctx2[1].floorList && /*propItem*/
          ctx2[1].floorList.length
        ) {
          if (if_block1) {
            if_block1.p(ctx2, dirty);
            if (dirty & /*propItem*/
            2) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_1(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(div16, t34);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (
          /*propHistories*/
          ctx2[0] && /*propHistories*/
          ctx2[0].length
        ) {
          if (if_block2) {
            if_block2.p(ctx2, dirty);
          } else {
            if_block2 = create_if_block(ctx2);
            if_block2.c();
            if_block2.m(div16, null);
          }
        } else if (if_block2) {
          if_block2.d(1);
          if_block2 = null;
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(if_block0);
        transition_in(icon0.$.fragment, local);
        transition_in(icon1.$.fragment, local);
        for (let i = 0; i < each_value_3.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        transition_in(if_block1);
        current = true;
      },
      o(local) {
        transition_out(if_block0);
        transition_out(icon0.$.fragment, local);
        transition_out(icon1.$.fragment, local);
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        transition_out(if_block1);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(div16);
        }
        if_blocks[current_block_type_index].d();
        destroy_component(icon0);
        destroy_each(each_blocks_1, detaching);
        destroy_component(icon1);
        destroy_each(each_blocks, detaching);
        if (if_block1)
          if_block1.d();
        if (if_block2)
          if_block2.d();
      }
    };
  }
  function instance4($self, $props, $invalidate) {
    let { propHistories } = $props;
    let { propItem: propItem2 } = $props;
    let { meta: meta2 } = $props;
    let approvalStatus = "approved";
    let signs = [
      { status: "approved", sign: "***" },
      { status: "rejected", sign: "**" },
      { status: "pending", sign: "*" }
    ];
    onMount(() => {
      console.log("onMount.Property");
      console.log("Property = ", propItem2);
      if (propItem2.approvalState !== "pending" && propItem2.approvalState !== "") {
        $invalidate(3, approvalStatus = "rejected");
      }
      if (propItem2.approvalState === "pending") {
        $invalidate(3, approvalStatus = "pending");
      }
    });
    $self.$set = ($props2) => {
      if ("propHistories" in $props2)
        $invalidate(0, propHistories = $props2.propHistories);
      if ("propItem" in $props2)
        $invalidate(1, propItem2 = $props2.propItem);
      if ("meta" in $props2)
        $invalidate(2, meta2 = $props2.meta);
    };
    return [propHistories, propItem2, meta2, approvalStatus, signs];
  }
  var Property = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment4, safe_not_equal, { propHistories: 0, propItem: 1, meta: 2 });
    }
  };
  var Property_default = Property;

  // guest/property/public.svelte
  function create_fragment5(ctx) {
    let growl;
    let t0;
    let section;
    let div0;
    let property;
    let t1;
    let div5;
    let div2;
    let div1;
    let t5;
    let a0;
    let span0;
    let t7;
    let icon0;
    let t8;
    let div4;
    let header;
    let span1;
    let t10;
    let icon1;
    let t11;
    let div3;
    let button;
    let icon2;
    let t12;
    let a1;
    let icon3;
    let a1_href_value;
    let t13;
    let a2;
    let icon4;
    let a2_href_value;
    let t14;
    let a3;
    let icon5;
    let a3_href_value;
    let t15;
    let a4;
    let icon6;
    let a4_href_value;
    let t16;
    let a5;
    let icon7;
    let a5_href_value;
    let current;
    let mounted;
    let dispose;
    let growl_props = {};
    growl = new Growl_default({ props: growl_props });
    ctx[1](growl);
    property = new Property_default({ props: { propItem, meta } });
    icon0 = new Icon_default({
      props: {
        color: "#FFF",
        size: 13,
        src: FaSolidArrowRight_default
      }
    });
    icon1 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#9fa9b5",
        size: 14,
        src: FaSolidShareAlt_default
      }
    });
    icon2 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 28,
        src: FaCopy_default
      }
    });
    icon3 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsFacebook_default
      }
    });
    icon4 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsLinkedin_default
      }
    });
    icon5 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsTwitter_default
      }
    });
    icon6 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 30,
        src: FaBrandsTelegram_default
      }
    });
    icon7 = new Icon_default({
      props: {
        className: "share_icon",
        color: "#475569",
        size: 33,
        src: FaBrandsWhatsapp_default
      }
    });
    return {
      c() {
        create_component(growl.$.fragment);
        t0 = space();
        section = element("section");
        div0 = element("div");
        create_component(property.$.fragment);
        t1 = space();
        div5 = element("div");
        div2 = element("div");
        div1 = element("div");
        div1.innerHTML = `<h3 class="svelte-vm9pc0">Login to</h3> <h3 class="svelte-vm9pc0">HapSTR</h3>`;
        t5 = space();
        a0 = element("a");
        span0 = element("span");
        span0.textContent = "Login";
        t7 = space();
        create_component(icon0.$.fragment);
        t8 = space();
        div4 = element("div");
        header = element("header");
        span1 = element("span");
        span1.textContent = "Share this";
        t10 = space();
        create_component(icon1.$.fragment);
        t11 = space();
        div3 = element("div");
        button = element("button");
        create_component(icon2.$.fragment);
        t12 = space();
        a1 = element("a");
        create_component(icon3.$.fragment);
        t13 = space();
        a2 = element("a");
        create_component(icon4.$.fragment);
        t14 = space();
        a3 = element("a");
        create_component(icon5.$.fragment);
        t15 = space();
        a4 = element("a");
        create_component(icon6.$.fragment);
        t16 = space();
        a5 = element("a");
        create_component(icon7.$.fragment);
        attr(div0, "class", "property svelte-vm9pc0");
        attr(a0, "class", "login_btn svelte-vm9pc0");
        attr(a0, "href", "/");
        attr(div2, "class", "login_container svelte-vm9pc0");
        attr(header, "class", "svelte-vm9pc0");
        attr(button, "class", "share_item svelte-vm9pc0");
        attr(button, "title", "Copy link address");
        attr(a1, "aria-label", "Share to Facebook");
        attr(a1, "class", "share_item svelte-vm9pc0");
        attr(a1, "href", a1_href_value = "https://www.facebook.com/sharer/sharer.php?u=" + window.location + "?utm_source=facebook&utm_medium=social&utm_campaign=user-share");
        attr(a1, "rel", "noopener");
        attr(a1, "target", "_blank");
        attr(a2, "aria-label", "Share to LinkedIn");
        attr(a2, "class", "share_item svelte-vm9pc0");
        attr(a2, "href", a2_href_value = "https://www.linkedin.com/shareArticle?mini=true&url=" + window.location + "&title=I%20Found%20Awesome%House%20" + window.location);
        attr(a2, "rel", "noopener");
        attr(a2, "target", "_blank");
        attr(a3, "aria-label", "Share to Twitter");
        attr(a3, "class", "share_item svelte-vm9pc0");
        attr(a3, "href", a3_href_value = "https://twitter.com/intent/tweet?url=" + window.location);
        attr(a3, "rel", "noopener");
        attr(a3, "target", "_blank");
        attr(a4, "aria-label", "Share to Telegram");
        attr(a4, "class", "share_item svelte-vm9pc0");
        attr(a4, "href", a4_href_value = "https://t.me/share/url?url=" + window.location);
        attr(a4, "rel", "noopener");
        attr(a4, "target", "_blank");
        attr(a5, "aria-label", "Share to WhatsApp");
        attr(a5, "class", "share_item svelte-vm9pc0");
        attr(a5, "href", a5_href_value = "https://api.whatsapp.com/send?text=I%20Found%20Awesome%20House%20" + window.location);
        attr(a5, "rel", "noopener");
        attr(a5, "target", "_blank");
        attr(div3, "class", "share_options svelte-vm9pc0");
        attr(div4, "class", "share_container svelte-vm9pc0");
        attr(div5, "class", "side_attribute svelte-vm9pc0");
        attr(section, "class", "property_container svelte-vm9pc0");
      },
      m(target, anchor) {
        mount_component(growl, target, anchor);
        insert(target, t0, anchor);
        insert(target, section, anchor);
        append(section, div0);
        mount_component(property, div0, null);
        append(section, t1);
        append(section, div5);
        append(div5, div2);
        append(div2, div1);
        append(div2, t5);
        append(div2, a0);
        append(a0, span0);
        append(a0, t7);
        mount_component(icon0, a0, null);
        append(div5, t8);
        append(div5, div4);
        append(div4, header);
        append(header, span1);
        append(header, t10);
        mount_component(icon1, header, null);
        append(div4, t11);
        append(div4, div3);
        append(div3, button);
        mount_component(icon2, button, null);
        append(div3, t12);
        append(div3, a1);
        mount_component(icon3, a1, null);
        append(div3, t13);
        append(div3, a2);
        mount_component(icon4, a2, null);
        append(div3, t14);
        append(div3, a3);
        mount_component(icon5, a3, null);
        append(div3, t15);
        append(div3, a4);
        mount_component(icon6, a4, null);
        append(div3, t16);
        append(div3, a5);
        mount_component(icon7, a5, null);
        current = true;
        if (!mounted) {
          dispose = listen(
            button,
            "click",
            /*click_handler*/
            ctx[2]
          );
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        const growl_changes = {};
        growl.$set(growl_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(growl.$.fragment, local);
        transition_in(property.$.fragment, local);
        transition_in(icon0.$.fragment, local);
        transition_in(icon1.$.fragment, local);
        transition_in(icon2.$.fragment, local);
        transition_in(icon3.$.fragment, local);
        transition_in(icon4.$.fragment, local);
        transition_in(icon5.$.fragment, local);
        transition_in(icon6.$.fragment, local);
        transition_in(icon7.$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(growl.$.fragment, local);
        transition_out(property.$.fragment, local);
        transition_out(icon0.$.fragment, local);
        transition_out(icon1.$.fragment, local);
        transition_out(icon2.$.fragment, local);
        transition_out(icon3.$.fragment, local);
        transition_out(icon4.$.fragment, local);
        transition_out(icon5.$.fragment, local);
        transition_out(icon6.$.fragment, local);
        transition_out(icon7.$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching) {
          detach(t0);
          detach(section);
        }
        ctx[1](null);
        destroy_component(growl, detaching);
        destroy_component(property);
        destroy_component(icon0);
        destroy_component(icon1);
        destroy_component(icon2);
        destroy_component(icon3);
        destroy_component(icon4);
        destroy_component(icon5);
        destroy_component(icon6);
        destroy_component(icon7);
        mounted = false;
        dispose();
      }
    };
  }
  var propItem = {/* propItem */};
  var meta = {/* propertyMeta */};
  function copyToClipboard(text2) {
    console.log(window.location);
    navigator.clipboard.writeText(text2);
    alert("Link copied to clipboard");
  }
  function instance5($self, $props, $invalidate) {
    let myGrowl = Growl_default;
    function growl_binding($value) {
      binding_callbacks[$value ? "unshift" : "push"](() => {
        myGrowl = $value;
        $invalidate(0, myGrowl);
      });
    }
    const click_handler = () => copyToClipboard(window.location);
    return [myGrowl, growl_binding, click_handler];
  }
  var Public = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance5, create_fragment5, safe_not_equal, {});
    }
  };
  var public_default = Public;

  // guest/property/public.svelte.ts
  var app = new public_default({ target: document.getElementById("app") });
})();
</script>
</body></html>